// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: NFMsgExtra.proto

#ifndef PROTOBUF_INCLUDED_NFMsgExtra_2eproto
#define PROTOBUF_INCLUDED_NFMsgExtra_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "NFMsgBase.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_NFMsgExtra_2eproto LIBPROTOC_EXPORT

namespace protobuf_NFMsgExtra_2eproto {
// Internal implementation detail -- do not use these members.
struct LIBPROTOC_EXPORT TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[29];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void LIBPROTOC_EXPORT AddDescriptors();
}  // namespace protobuf_NFMsgExtra_2eproto
namespace NFMsg {
class AckBigMapGridInfo;
class AckBigMapGridInfoDefaultTypeInternal;
LIBPROTOC_EXPORT extern AckBigMapGridInfoDefaultTypeInternal _AckBigMapGridInfo_default_instance_;
class AckBigMapInfo;
class AckBigMapInfoDefaultTypeInternal;
LIBPROTOC_EXPORT extern AckBigMapInfoDefaultTypeInternal _AckBigMapInfo_default_instance_;
class AckGetMapAward;
class AckGetMapAwardDefaultTypeInternal;
LIBPROTOC_EXPORT extern AckGetMapAwardDefaultTypeInternal _AckGetMapAward_default_instance_;
class AckHoldMapGrid;
class AckHoldMapGridDefaultTypeInternal;
LIBPROTOC_EXPORT extern AckHoldMapGridDefaultTypeInternal _AckHoldMapGrid_default_instance_;
class AckLeaveMapMsg;
class AckLeaveMapMsgDefaultTypeInternal;
LIBPROTOC_EXPORT extern AckLeaveMapMsgDefaultTypeInternal _AckLeaveMapMsg_default_instance_;
class AckMapHunting;
class AckMapHuntingDefaultTypeInternal;
LIBPROTOC_EXPORT extern AckMapHuntingDefaultTypeInternal _AckMapHunting_default_instance_;
class AckMapKingWar;
class AckMapKingWarDefaultTypeInternal;
LIBPROTOC_EXPORT extern AckMapKingWarDefaultTypeInternal _AckMapKingWar_default_instance_;
class AckTeamEnterEctype;
class AckTeamEnterEctypeDefaultTypeInternal;
LIBPROTOC_EXPORT extern AckTeamEnterEctypeDefaultTypeInternal _AckTeamEnterEctype_default_instance_;
class BigMapGridBaseInfo;
class BigMapGridBaseInfoDefaultTypeInternal;
LIBPROTOC_EXPORT extern BigMapGridBaseInfoDefaultTypeInternal _BigMapGridBaseInfo_default_instance_;
class BigMapGridDetailInfo;
class BigMapGridDetailInfoDefaultTypeInternal;
LIBPROTOC_EXPORT extern BigMapGridDetailInfoDefaultTypeInternal _BigMapGridDetailInfo_default_instance_;
class BigMapLeaveMsg;
class BigMapLeaveMsgDefaultTypeInternal;
LIBPROTOC_EXPORT extern BigMapLeaveMsgDefaultTypeInternal _BigMapLeaveMsg_default_instance_;
class BigMapWarHistory;
class BigMapWarHistoryDefaultTypeInternal;
LIBPROTOC_EXPORT extern BigMapWarHistoryDefaultTypeInternal _BigMapWarHistory_default_instance_;
class GridClanBaseInfo;
class GridClanBaseInfoDefaultTypeInternal;
LIBPROTOC_EXPORT extern GridClanBaseInfoDefaultTypeInternal _GridClanBaseInfo_default_instance_;
class ReqAIOnwer;
class ReqAIOnwerDefaultTypeInternal;
LIBPROTOC_EXPORT extern ReqAIOnwerDefaultTypeInternal _ReqAIOnwer_default_instance_;
class ReqAckCreateTeam;
class ReqAckCreateTeamDefaultTypeInternal;
LIBPROTOC_EXPORT extern ReqAckCreateTeamDefaultTypeInternal _ReqAckCreateTeam_default_instance_;
class ReqAckInviteTeam;
class ReqAckInviteTeamDefaultTypeInternal;
LIBPROTOC_EXPORT extern ReqAckInviteTeamDefaultTypeInternal _ReqAckInviteTeam_default_instance_;
class ReqAckJoinTeam;
class ReqAckJoinTeamDefaultTypeInternal;
LIBPROTOC_EXPORT extern ReqAckJoinTeamDefaultTypeInternal _ReqAckJoinTeam_default_instance_;
class ReqAckLeaveTeam;
class ReqAckLeaveTeamDefaultTypeInternal;
LIBPROTOC_EXPORT extern ReqAckLeaveTeamDefaultTypeInternal _ReqAckLeaveTeam_default_instance_;
class ReqAckOprTeamMember;
class ReqAckOprTeamMemberDefaultTypeInternal;
LIBPROTOC_EXPORT extern ReqAckOprTeamMemberDefaultTypeInternal _ReqAckOprTeamMember_default_instance_;
class ReqBigMapGridInfo;
class ReqBigMapGridInfoDefaultTypeInternal;
LIBPROTOC_EXPORT extern ReqBigMapGridInfoDefaultTypeInternal _ReqBigMapGridInfo_default_instance_;
class ReqBigMapInfo;
class ReqBigMapInfoDefaultTypeInternal;
LIBPROTOC_EXPORT extern ReqBigMapInfoDefaultTypeInternal _ReqBigMapInfo_default_instance_;
class ReqGetMapAward;
class ReqGetMapAwardDefaultTypeInternal;
LIBPROTOC_EXPORT extern ReqGetMapAwardDefaultTypeInternal _ReqGetMapAward_default_instance_;
class ReqHoldMapGrid;
class ReqHoldMapGridDefaultTypeInternal;
LIBPROTOC_EXPORT extern ReqHoldMapGridDefaultTypeInternal _ReqHoldMapGrid_default_instance_;
class ReqLeaveMapMsg;
class ReqLeaveMapMsgDefaultTypeInternal;
LIBPROTOC_EXPORT extern ReqLeaveMapMsgDefaultTypeInternal _ReqLeaveMapMsg_default_instance_;
class ReqMapHunting;
class ReqMapHuntingDefaultTypeInternal;
LIBPROTOC_EXPORT extern ReqMapHuntingDefaultTypeInternal _ReqMapHunting_default_instance_;
class ReqMapKingWar;
class ReqMapKingWarDefaultTypeInternal;
LIBPROTOC_EXPORT extern ReqMapKingWarDefaultTypeInternal _ReqMapKingWar_default_instance_;
class ReqTeamEnterEctype;
class ReqTeamEnterEctypeDefaultTypeInternal;
LIBPROTOC_EXPORT extern ReqTeamEnterEctypeDefaultTypeInternal _ReqTeamEnterEctype_default_instance_;
class TeamInfo;
class TeamInfoDefaultTypeInternal;
LIBPROTOC_EXPORT extern TeamInfoDefaultTypeInternal _TeamInfo_default_instance_;
class TeammemberInfo;
class TeammemberInfoDefaultTypeInternal;
LIBPROTOC_EXPORT extern TeammemberInfoDefaultTypeInternal _TeammemberInfo_default_instance_;
}  // namespace NFMsg
namespace google {
namespace protobuf {
template<> LIBPROTOC_EXPORT ::NFMsg::AckBigMapGridInfo* Arena::CreateMaybeMessage<::NFMsg::AckBigMapGridInfo>(Arena*);
template<> LIBPROTOC_EXPORT ::NFMsg::AckBigMapInfo* Arena::CreateMaybeMessage<::NFMsg::AckBigMapInfo>(Arena*);
template<> LIBPROTOC_EXPORT ::NFMsg::AckGetMapAward* Arena::CreateMaybeMessage<::NFMsg::AckGetMapAward>(Arena*);
template<> LIBPROTOC_EXPORT ::NFMsg::AckHoldMapGrid* Arena::CreateMaybeMessage<::NFMsg::AckHoldMapGrid>(Arena*);
template<> LIBPROTOC_EXPORT ::NFMsg::AckLeaveMapMsg* Arena::CreateMaybeMessage<::NFMsg::AckLeaveMapMsg>(Arena*);
template<> LIBPROTOC_EXPORT ::NFMsg::AckMapHunting* Arena::CreateMaybeMessage<::NFMsg::AckMapHunting>(Arena*);
template<> LIBPROTOC_EXPORT ::NFMsg::AckMapKingWar* Arena::CreateMaybeMessage<::NFMsg::AckMapKingWar>(Arena*);
template<> LIBPROTOC_EXPORT ::NFMsg::AckTeamEnterEctype* Arena::CreateMaybeMessage<::NFMsg::AckTeamEnterEctype>(Arena*);
template<> LIBPROTOC_EXPORT ::NFMsg::BigMapGridBaseInfo* Arena::CreateMaybeMessage<::NFMsg::BigMapGridBaseInfo>(Arena*);
template<> LIBPROTOC_EXPORT ::NFMsg::BigMapGridDetailInfo* Arena::CreateMaybeMessage<::NFMsg::BigMapGridDetailInfo>(Arena*);
template<> LIBPROTOC_EXPORT ::NFMsg::BigMapLeaveMsg* Arena::CreateMaybeMessage<::NFMsg::BigMapLeaveMsg>(Arena*);
template<> LIBPROTOC_EXPORT ::NFMsg::BigMapWarHistory* Arena::CreateMaybeMessage<::NFMsg::BigMapWarHistory>(Arena*);
template<> LIBPROTOC_EXPORT ::NFMsg::GridClanBaseInfo* Arena::CreateMaybeMessage<::NFMsg::GridClanBaseInfo>(Arena*);
template<> LIBPROTOC_EXPORT ::NFMsg::ReqAIOnwer* Arena::CreateMaybeMessage<::NFMsg::ReqAIOnwer>(Arena*);
template<> LIBPROTOC_EXPORT ::NFMsg::ReqAckCreateTeam* Arena::CreateMaybeMessage<::NFMsg::ReqAckCreateTeam>(Arena*);
template<> LIBPROTOC_EXPORT ::NFMsg::ReqAckInviteTeam* Arena::CreateMaybeMessage<::NFMsg::ReqAckInviteTeam>(Arena*);
template<> LIBPROTOC_EXPORT ::NFMsg::ReqAckJoinTeam* Arena::CreateMaybeMessage<::NFMsg::ReqAckJoinTeam>(Arena*);
template<> LIBPROTOC_EXPORT ::NFMsg::ReqAckLeaveTeam* Arena::CreateMaybeMessage<::NFMsg::ReqAckLeaveTeam>(Arena*);
template<> LIBPROTOC_EXPORT ::NFMsg::ReqAckOprTeamMember* Arena::CreateMaybeMessage<::NFMsg::ReqAckOprTeamMember>(Arena*);
template<> LIBPROTOC_EXPORT ::NFMsg::ReqBigMapGridInfo* Arena::CreateMaybeMessage<::NFMsg::ReqBigMapGridInfo>(Arena*);
template<> LIBPROTOC_EXPORT ::NFMsg::ReqBigMapInfo* Arena::CreateMaybeMessage<::NFMsg::ReqBigMapInfo>(Arena*);
template<> LIBPROTOC_EXPORT ::NFMsg::ReqGetMapAward* Arena::CreateMaybeMessage<::NFMsg::ReqGetMapAward>(Arena*);
template<> LIBPROTOC_EXPORT ::NFMsg::ReqHoldMapGrid* Arena::CreateMaybeMessage<::NFMsg::ReqHoldMapGrid>(Arena*);
template<> LIBPROTOC_EXPORT ::NFMsg::ReqLeaveMapMsg* Arena::CreateMaybeMessage<::NFMsg::ReqLeaveMapMsg>(Arena*);
template<> LIBPROTOC_EXPORT ::NFMsg::ReqMapHunting* Arena::CreateMaybeMessage<::NFMsg::ReqMapHunting>(Arena*);
template<> LIBPROTOC_EXPORT ::NFMsg::ReqMapKingWar* Arena::CreateMaybeMessage<::NFMsg::ReqMapKingWar>(Arena*);
template<> LIBPROTOC_EXPORT ::NFMsg::ReqTeamEnterEctype* Arena::CreateMaybeMessage<::NFMsg::ReqTeamEnterEctype>(Arena*);
template<> LIBPROTOC_EXPORT ::NFMsg::TeamInfo* Arena::CreateMaybeMessage<::NFMsg::TeamInfo>(Arena*);
template<> LIBPROTOC_EXPORT ::NFMsg::TeammemberInfo* Arena::CreateMaybeMessage<::NFMsg::TeammemberInfo>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace NFMsg {

enum ReqAckOprTeamMember_EGTeamMemberOprType {
  ReqAckOprTeamMember_EGTeamMemberOprType_EGAT_DOWN = 0,
  ReqAckOprTeamMember_EGTeamMemberOprType_EGAT_UP = 1,
  ReqAckOprTeamMember_EGTeamMemberOprType_EGAT_KICK = 2,
  ReqAckOprTeamMember_EGTeamMemberOprType_EGAT_APPOINT = 3,
  ReqAckOprTeamMember_EGTeamMemberOprType_EGAT_FIRE = 4,
  ReqAckOprTeamMember_EGTeamMemberOprType_EGAT_DEMISE = 5,
  ReqAckOprTeamMember_EGTeamMemberOprType_EGAT_ACCEPTAPPLY = 6,
  ReqAckOprTeamMember_EGTeamMemberOprType_EGAT_DENYAPPLY = 7,
  ReqAckOprTeamMember_EGTeamMemberOprType_EGAT_KICKOUT = 8,
  ReqAckOprTeamMember_EGTeamMemberOprType_ReqAckOprTeamMember_EGTeamMemberOprType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ReqAckOprTeamMember_EGTeamMemberOprType_ReqAckOprTeamMember_EGTeamMemberOprType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
LIBPROTOC_EXPORT bool ReqAckOprTeamMember_EGTeamMemberOprType_IsValid(int value);
const ReqAckOprTeamMember_EGTeamMemberOprType ReqAckOprTeamMember_EGTeamMemberOprType_EGTeamMemberOprType_MIN = ReqAckOprTeamMember_EGTeamMemberOprType_EGAT_DOWN;
const ReqAckOprTeamMember_EGTeamMemberOprType ReqAckOprTeamMember_EGTeamMemberOprType_EGTeamMemberOprType_MAX = ReqAckOprTeamMember_EGTeamMemberOprType_EGAT_KICKOUT;
const int ReqAckOprTeamMember_EGTeamMemberOprType_EGTeamMemberOprType_ARRAYSIZE = ReqAckOprTeamMember_EGTeamMemberOprType_EGTeamMemberOprType_MAX + 1;

LIBPROTOC_EXPORT const ::google::protobuf::EnumDescriptor* ReqAckOprTeamMember_EGTeamMemberOprType_descriptor();
inline const ::std::string& ReqAckOprTeamMember_EGTeamMemberOprType_Name(ReqAckOprTeamMember_EGTeamMemberOprType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ReqAckOprTeamMember_EGTeamMemberOprType_descriptor(), value);
}
inline bool ReqAckOprTeamMember_EGTeamMemberOprType_Parse(
    const ::std::string& name, ReqAckOprTeamMember_EGTeamMemberOprType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ReqAckOprTeamMember_EGTeamMemberOprType>(
    ReqAckOprTeamMember_EGTeamMemberOprType_descriptor(), name, value);
}
// ===================================================================

class LIBPROTOC_EXPORT ReqAIOnwer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NFMsg.ReqAIOnwer) */ {
 public:
  ReqAIOnwer();
  virtual ~ReqAIOnwer();

  ReqAIOnwer(const ReqAIOnwer& from);

  inline ReqAIOnwer& operator=(const ReqAIOnwer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReqAIOnwer(ReqAIOnwer&& from) noexcept
    : ReqAIOnwer() {
    *this = ::std::move(from);
  }

  inline ReqAIOnwer& operator=(ReqAIOnwer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqAIOnwer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReqAIOnwer* internal_default_instance() {
    return reinterpret_cast<const ReqAIOnwer*>(
               &_ReqAIOnwer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(ReqAIOnwer* other);
  friend void swap(ReqAIOnwer& a, ReqAIOnwer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReqAIOnwer* New() const final {
    return CreateMaybeMessage<ReqAIOnwer>(NULL);
  }

  ReqAIOnwer* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReqAIOnwer>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReqAIOnwer& from);
  void MergeFrom(const ReqAIOnwer& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqAIOnwer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .NFMsg.Ident ai_id = 1;
  bool has_ai_id() const;
  void clear_ai_id();
  static const int kAiIdFieldNumber = 1;
  private:
  const ::NFMsg::Ident& _internal_ai_id() const;
  public:
  const ::NFMsg::Ident& ai_id() const;
  ::NFMsg::Ident* release_ai_id();
  ::NFMsg::Ident* mutable_ai_id();
  void set_allocated_ai_id(::NFMsg::Ident* ai_id);

  // @@protoc_insertion_point(class_scope:NFMsg.ReqAIOnwer)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::NFMsg::Ident* ai_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NFMsgExtra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT TeamInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NFMsg.TeamInfo) */ {
 public:
  TeamInfo();
  virtual ~TeamInfo();

  TeamInfo(const TeamInfo& from);

  inline TeamInfo& operator=(const TeamInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TeamInfo(TeamInfo&& from) noexcept
    : TeamInfo() {
    *this = ::std::move(from);
  }

  inline TeamInfo& operator=(TeamInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TeamInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TeamInfo* internal_default_instance() {
    return reinterpret_cast<const TeamInfo*>(
               &_TeamInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(TeamInfo* other);
  friend void swap(TeamInfo& a, TeamInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TeamInfo* New() const final {
    return CreateMaybeMessage<TeamInfo>(NULL);
  }

  TeamInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TeamInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TeamInfo& from);
  void MergeFrom(const TeamInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TeamInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .NFMsg.TeammemberInfo teammemberInfo = 3;
  int teammemberinfo_size() const;
  void clear_teammemberinfo();
  static const int kTeammemberInfoFieldNumber = 3;
  ::NFMsg::TeammemberInfo* mutable_teammemberinfo(int index);
  ::google::protobuf::RepeatedPtrField< ::NFMsg::TeammemberInfo >*
      mutable_teammemberinfo();
  const ::NFMsg::TeammemberInfo& teammemberinfo(int index) const;
  ::NFMsg::TeammemberInfo* add_teammemberinfo();
  const ::google::protobuf::RepeatedPtrField< ::NFMsg::TeammemberInfo >&
      teammemberinfo() const;

  // .NFMsg.Ident team_id = 1;
  bool has_team_id() const;
  void clear_team_id();
  static const int kTeamIdFieldNumber = 1;
  private:
  const ::NFMsg::Ident& _internal_team_id() const;
  public:
  const ::NFMsg::Ident& team_id() const;
  ::NFMsg::Ident* release_team_id();
  ::NFMsg::Ident* mutable_team_id();
  void set_allocated_team_id(::NFMsg::Ident* team_id);

  // .NFMsg.Ident captain_id = 2;
  bool has_captain_id() const;
  void clear_captain_id();
  static const int kCaptainIdFieldNumber = 2;
  private:
  const ::NFMsg::Ident& _internal_captain_id() const;
  public:
  const ::NFMsg::Ident& captain_id() const;
  ::NFMsg::Ident* release_captain_id();
  ::NFMsg::Ident* mutable_captain_id();
  void set_allocated_captain_id(::NFMsg::Ident* captain_id);

  // @@protoc_insertion_point(class_scope:NFMsg.TeamInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::NFMsg::TeammemberInfo > teammemberinfo_;
  ::NFMsg::Ident* team_id_;
  ::NFMsg::Ident* captain_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NFMsgExtra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT TeammemberInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NFMsg.TeammemberInfo) */ {
 public:
  TeammemberInfo();
  virtual ~TeammemberInfo();

  TeammemberInfo(const TeammemberInfo& from);

  inline TeammemberInfo& operator=(const TeammemberInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TeammemberInfo(TeammemberInfo&& from) noexcept
    : TeammemberInfo() {
    *this = ::std::move(from);
  }

  inline TeammemberInfo& operator=(TeammemberInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TeammemberInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TeammemberInfo* internal_default_instance() {
    return reinterpret_cast<const TeammemberInfo*>(
               &_TeammemberInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(TeammemberInfo* other);
  friend void swap(TeammemberInfo& a, TeammemberInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TeammemberInfo* New() const final {
    return CreateMaybeMessage<TeammemberInfo>(NULL);
  }

  TeammemberInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TeammemberInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TeammemberInfo& from);
  void MergeFrom(const TeammemberInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TeammemberInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string HeadIcon = 5;
  void clear_headicon();
  static const int kHeadIconFieldNumber = 5;
  const ::std::string& headicon() const;
  void set_headicon(const ::std::string& value);
  #if LANG_CXX11
  void set_headicon(::std::string&& value);
  #endif
  void set_headicon(const char* value);
  void set_headicon(const char* value, size_t size);
  ::std::string* mutable_headicon();
  ::std::string* release_headicon();
  void set_allocated_headicon(::std::string* headicon);

  // .NFMsg.Ident player_id = 1;
  bool has_player_id() const;
  void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  private:
  const ::NFMsg::Ident& _internal_player_id() const;
  public:
  const ::NFMsg::Ident& player_id() const;
  ::NFMsg::Ident* release_player_id();
  ::NFMsg::Ident* mutable_player_id();
  void set_allocated_player_id(::NFMsg::Ident* player_id);

  // int32 nLevel = 3;
  void clear_nlevel();
  static const int kNLevelFieldNumber = 3;
  ::google::protobuf::int32 nlevel() const;
  void set_nlevel(::google::protobuf::int32 value);

  // int32 job = 4;
  void clear_job();
  static const int kJobFieldNumber = 4;
  ::google::protobuf::int32 job() const;
  void set_job(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:NFMsg.TeammemberInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr headicon_;
  ::NFMsg::Ident* player_id_;
  ::google::protobuf::int32 nlevel_;
  ::google::protobuf::int32 job_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NFMsgExtra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ReqAckCreateTeam : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NFMsg.ReqAckCreateTeam) */ {
 public:
  ReqAckCreateTeam();
  virtual ~ReqAckCreateTeam();

  ReqAckCreateTeam(const ReqAckCreateTeam& from);

  inline ReqAckCreateTeam& operator=(const ReqAckCreateTeam& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReqAckCreateTeam(ReqAckCreateTeam&& from) noexcept
    : ReqAckCreateTeam() {
    *this = ::std::move(from);
  }

  inline ReqAckCreateTeam& operator=(ReqAckCreateTeam&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqAckCreateTeam& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReqAckCreateTeam* internal_default_instance() {
    return reinterpret_cast<const ReqAckCreateTeam*>(
               &_ReqAckCreateTeam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(ReqAckCreateTeam* other);
  friend void swap(ReqAckCreateTeam& a, ReqAckCreateTeam& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReqAckCreateTeam* New() const final {
    return CreateMaybeMessage<ReqAckCreateTeam>(NULL);
  }

  ReqAckCreateTeam* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReqAckCreateTeam>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReqAckCreateTeam& from);
  void MergeFrom(const ReqAckCreateTeam& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqAckCreateTeam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .NFMsg.Ident team_id = 1;
  bool has_team_id() const;
  void clear_team_id();
  static const int kTeamIdFieldNumber = 1;
  private:
  const ::NFMsg::Ident& _internal_team_id() const;
  public:
  const ::NFMsg::Ident& team_id() const;
  ::NFMsg::Ident* release_team_id();
  ::NFMsg::Ident* mutable_team_id();
  void set_allocated_team_id(::NFMsg::Ident* team_id);

  // .NFMsg.TeamInfo xTeamInfo = 2;
  bool has_xteaminfo() const;
  void clear_xteaminfo();
  static const int kXTeamInfoFieldNumber = 2;
  private:
  const ::NFMsg::TeamInfo& _internal_xteaminfo() const;
  public:
  const ::NFMsg::TeamInfo& xteaminfo() const;
  ::NFMsg::TeamInfo* release_xteaminfo();
  ::NFMsg::TeamInfo* mutable_xteaminfo();
  void set_allocated_xteaminfo(::NFMsg::TeamInfo* xteaminfo);

  // @@protoc_insertion_point(class_scope:NFMsg.ReqAckCreateTeam)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::NFMsg::Ident* team_id_;
  ::NFMsg::TeamInfo* xteaminfo_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NFMsgExtra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ReqAckJoinTeam : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NFMsg.ReqAckJoinTeam) */ {
 public:
  ReqAckJoinTeam();
  virtual ~ReqAckJoinTeam();

  ReqAckJoinTeam(const ReqAckJoinTeam& from);

  inline ReqAckJoinTeam& operator=(const ReqAckJoinTeam& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReqAckJoinTeam(ReqAckJoinTeam&& from) noexcept
    : ReqAckJoinTeam() {
    *this = ::std::move(from);
  }

  inline ReqAckJoinTeam& operator=(ReqAckJoinTeam&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqAckJoinTeam& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReqAckJoinTeam* internal_default_instance() {
    return reinterpret_cast<const ReqAckJoinTeam*>(
               &_ReqAckJoinTeam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(ReqAckJoinTeam* other);
  friend void swap(ReqAckJoinTeam& a, ReqAckJoinTeam& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReqAckJoinTeam* New() const final {
    return CreateMaybeMessage<ReqAckJoinTeam>(NULL);
  }

  ReqAckJoinTeam* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReqAckJoinTeam>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReqAckJoinTeam& from);
  void MergeFrom(const ReqAckJoinTeam& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqAckJoinTeam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .NFMsg.Ident team_id = 1;
  bool has_team_id() const;
  void clear_team_id();
  static const int kTeamIdFieldNumber = 1;
  private:
  const ::NFMsg::Ident& _internal_team_id() const;
  public:
  const ::NFMsg::Ident& team_id() const;
  ::NFMsg::Ident* release_team_id();
  ::NFMsg::Ident* mutable_team_id();
  void set_allocated_team_id(::NFMsg::Ident* team_id);

  // .NFMsg.TeamInfo xTeamInfo = 2;
  bool has_xteaminfo() const;
  void clear_xteaminfo();
  static const int kXTeamInfoFieldNumber = 2;
  private:
  const ::NFMsg::TeamInfo& _internal_xteaminfo() const;
  public:
  const ::NFMsg::TeamInfo& xteaminfo() const;
  ::NFMsg::TeamInfo* release_xteaminfo();
  ::NFMsg::TeamInfo* mutable_xteaminfo();
  void set_allocated_xteaminfo(::NFMsg::TeamInfo* xteaminfo);

  // @@protoc_insertion_point(class_scope:NFMsg.ReqAckJoinTeam)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::NFMsg::Ident* team_id_;
  ::NFMsg::TeamInfo* xteaminfo_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NFMsgExtra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ReqAckLeaveTeam : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NFMsg.ReqAckLeaveTeam) */ {
 public:
  ReqAckLeaveTeam();
  virtual ~ReqAckLeaveTeam();

  ReqAckLeaveTeam(const ReqAckLeaveTeam& from);

  inline ReqAckLeaveTeam& operator=(const ReqAckLeaveTeam& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReqAckLeaveTeam(ReqAckLeaveTeam&& from) noexcept
    : ReqAckLeaveTeam() {
    *this = ::std::move(from);
  }

  inline ReqAckLeaveTeam& operator=(ReqAckLeaveTeam&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqAckLeaveTeam& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReqAckLeaveTeam* internal_default_instance() {
    return reinterpret_cast<const ReqAckLeaveTeam*>(
               &_ReqAckLeaveTeam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(ReqAckLeaveTeam* other);
  friend void swap(ReqAckLeaveTeam& a, ReqAckLeaveTeam& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReqAckLeaveTeam* New() const final {
    return CreateMaybeMessage<ReqAckLeaveTeam>(NULL);
  }

  ReqAckLeaveTeam* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReqAckLeaveTeam>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReqAckLeaveTeam& from);
  void MergeFrom(const ReqAckLeaveTeam& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqAckLeaveTeam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .NFMsg.Ident team_id = 1;
  bool has_team_id() const;
  void clear_team_id();
  static const int kTeamIdFieldNumber = 1;
  private:
  const ::NFMsg::Ident& _internal_team_id() const;
  public:
  const ::NFMsg::Ident& team_id() const;
  ::NFMsg::Ident* release_team_id();
  ::NFMsg::Ident* mutable_team_id();
  void set_allocated_team_id(::NFMsg::Ident* team_id);

  // .NFMsg.TeamInfo xTeamInfo = 2;
  bool has_xteaminfo() const;
  void clear_xteaminfo();
  static const int kXTeamInfoFieldNumber = 2;
  private:
  const ::NFMsg::TeamInfo& _internal_xteaminfo() const;
  public:
  const ::NFMsg::TeamInfo& xteaminfo() const;
  ::NFMsg::TeamInfo* release_xteaminfo();
  ::NFMsg::TeamInfo* mutable_xteaminfo();
  void set_allocated_xteaminfo(::NFMsg::TeamInfo* xteaminfo);

  // @@protoc_insertion_point(class_scope:NFMsg.ReqAckLeaveTeam)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::NFMsg::Ident* team_id_;
  ::NFMsg::TeamInfo* xteaminfo_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NFMsgExtra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ReqAckOprTeamMember : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NFMsg.ReqAckOprTeamMember) */ {
 public:
  ReqAckOprTeamMember();
  virtual ~ReqAckOprTeamMember();

  ReqAckOprTeamMember(const ReqAckOprTeamMember& from);

  inline ReqAckOprTeamMember& operator=(const ReqAckOprTeamMember& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReqAckOprTeamMember(ReqAckOprTeamMember&& from) noexcept
    : ReqAckOprTeamMember() {
    *this = ::std::move(from);
  }

  inline ReqAckOprTeamMember& operator=(ReqAckOprTeamMember&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqAckOprTeamMember& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReqAckOprTeamMember* internal_default_instance() {
    return reinterpret_cast<const ReqAckOprTeamMember*>(
               &_ReqAckOprTeamMember_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(ReqAckOprTeamMember* other);
  friend void swap(ReqAckOprTeamMember& a, ReqAckOprTeamMember& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReqAckOprTeamMember* New() const final {
    return CreateMaybeMessage<ReqAckOprTeamMember>(NULL);
  }

  ReqAckOprTeamMember* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReqAckOprTeamMember>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReqAckOprTeamMember& from);
  void MergeFrom(const ReqAckOprTeamMember& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqAckOprTeamMember* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ReqAckOprTeamMember_EGTeamMemberOprType EGTeamMemberOprType;
  static const EGTeamMemberOprType EGAT_DOWN =
    ReqAckOprTeamMember_EGTeamMemberOprType_EGAT_DOWN;
  static const EGTeamMemberOprType EGAT_UP =
    ReqAckOprTeamMember_EGTeamMemberOprType_EGAT_UP;
  static const EGTeamMemberOprType EGAT_KICK =
    ReqAckOprTeamMember_EGTeamMemberOprType_EGAT_KICK;
  static const EGTeamMemberOprType EGAT_APPOINT =
    ReqAckOprTeamMember_EGTeamMemberOprType_EGAT_APPOINT;
  static const EGTeamMemberOprType EGAT_FIRE =
    ReqAckOprTeamMember_EGTeamMemberOprType_EGAT_FIRE;
  static const EGTeamMemberOprType EGAT_DEMISE =
    ReqAckOprTeamMember_EGTeamMemberOprType_EGAT_DEMISE;
  static const EGTeamMemberOprType EGAT_ACCEPTAPPLY =
    ReqAckOprTeamMember_EGTeamMemberOprType_EGAT_ACCEPTAPPLY;
  static const EGTeamMemberOprType EGAT_DENYAPPLY =
    ReqAckOprTeamMember_EGTeamMemberOprType_EGAT_DENYAPPLY;
  static const EGTeamMemberOprType EGAT_KICKOUT =
    ReqAckOprTeamMember_EGTeamMemberOprType_EGAT_KICKOUT;
  static inline bool EGTeamMemberOprType_IsValid(int value) {
    return ReqAckOprTeamMember_EGTeamMemberOprType_IsValid(value);
  }
  static const EGTeamMemberOprType EGTeamMemberOprType_MIN =
    ReqAckOprTeamMember_EGTeamMemberOprType_EGTeamMemberOprType_MIN;
  static const EGTeamMemberOprType EGTeamMemberOprType_MAX =
    ReqAckOprTeamMember_EGTeamMemberOprType_EGTeamMemberOprType_MAX;
  static const int EGTeamMemberOprType_ARRAYSIZE =
    ReqAckOprTeamMember_EGTeamMemberOprType_EGTeamMemberOprType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EGTeamMemberOprType_descriptor() {
    return ReqAckOprTeamMember_EGTeamMemberOprType_descriptor();
  }
  static inline const ::std::string& EGTeamMemberOprType_Name(EGTeamMemberOprType value) {
    return ReqAckOprTeamMember_EGTeamMemberOprType_Name(value);
  }
  static inline bool EGTeamMemberOprType_Parse(const ::std::string& name,
      EGTeamMemberOprType* value) {
    return ReqAckOprTeamMember_EGTeamMemberOprType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .NFMsg.Ident team_id = 1;
  bool has_team_id() const;
  void clear_team_id();
  static const int kTeamIdFieldNumber = 1;
  private:
  const ::NFMsg::Ident& _internal_team_id() const;
  public:
  const ::NFMsg::Ident& team_id() const;
  ::NFMsg::Ident* release_team_id();
  ::NFMsg::Ident* mutable_team_id();
  void set_allocated_team_id(::NFMsg::Ident* team_id);

  // .NFMsg.Ident member_id = 2;
  bool has_member_id() const;
  void clear_member_id();
  static const int kMemberIdFieldNumber = 2;
  private:
  const ::NFMsg::Ident& _internal_member_id() const;
  public:
  const ::NFMsg::Ident& member_id() const;
  ::NFMsg::Ident* release_member_id();
  ::NFMsg::Ident* mutable_member_id();
  void set_allocated_member_id(::NFMsg::Ident* member_id);

  // .NFMsg.TeamInfo xTeamInfo = 4;
  bool has_xteaminfo() const;
  void clear_xteaminfo();
  static const int kXTeamInfoFieldNumber = 4;
  private:
  const ::NFMsg::TeamInfo& _internal_xteaminfo() const;
  public:
  const ::NFMsg::TeamInfo& xteaminfo() const;
  ::NFMsg::TeamInfo* release_xteaminfo();
  ::NFMsg::TeamInfo* mutable_xteaminfo();
  void set_allocated_xteaminfo(::NFMsg::TeamInfo* xteaminfo);

  // .NFMsg.ReqAckOprTeamMember.EGTeamMemberOprType type = 3;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::NFMsg::ReqAckOprTeamMember_EGTeamMemberOprType type() const;
  void set_type(::NFMsg::ReqAckOprTeamMember_EGTeamMemberOprType value);

  // @@protoc_insertion_point(class_scope:NFMsg.ReqAckOprTeamMember)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::NFMsg::Ident* team_id_;
  ::NFMsg::Ident* member_id_;
  ::NFMsg::TeamInfo* xteaminfo_;
  int type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NFMsgExtra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ReqAckInviteTeam : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NFMsg.ReqAckInviteTeam) */ {
 public:
  ReqAckInviteTeam();
  virtual ~ReqAckInviteTeam();

  ReqAckInviteTeam(const ReqAckInviteTeam& from);

  inline ReqAckInviteTeam& operator=(const ReqAckInviteTeam& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReqAckInviteTeam(ReqAckInviteTeam&& from) noexcept
    : ReqAckInviteTeam() {
    *this = ::std::move(from);
  }

  inline ReqAckInviteTeam& operator=(ReqAckInviteTeam&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqAckInviteTeam& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReqAckInviteTeam* internal_default_instance() {
    return reinterpret_cast<const ReqAckInviteTeam*>(
               &_ReqAckInviteTeam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(ReqAckInviteTeam* other);
  friend void swap(ReqAckInviteTeam& a, ReqAckInviteTeam& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReqAckInviteTeam* New() const final {
    return CreateMaybeMessage<ReqAckInviteTeam>(NULL);
  }

  ReqAckInviteTeam* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReqAckInviteTeam>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReqAckInviteTeam& from);
  void MergeFrom(const ReqAckInviteTeam& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqAckInviteTeam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .NFMsg.Ident team_id = 1;
  bool has_team_id() const;
  void clear_team_id();
  static const int kTeamIdFieldNumber = 1;
  private:
  const ::NFMsg::Ident& _internal_team_id() const;
  public:
  const ::NFMsg::Ident& team_id() const;
  ::NFMsg::Ident* release_team_id();
  ::NFMsg::Ident* mutable_team_id();
  void set_allocated_team_id(::NFMsg::Ident* team_id);

  // .NFMsg.Ident self_id = 2;
  bool has_self_id() const;
  void clear_self_id();
  static const int kSelfIdFieldNumber = 2;
  private:
  const ::NFMsg::Ident& _internal_self_id() const;
  public:
  const ::NFMsg::Ident& self_id() const;
  ::NFMsg::Ident* release_self_id();
  ::NFMsg::Ident* mutable_self_id();
  void set_allocated_self_id(::NFMsg::Ident* self_id);

  // .NFMsg.Ident invite_target_id = 3;
  bool has_invite_target_id() const;
  void clear_invite_target_id();
  static const int kInviteTargetIdFieldNumber = 3;
  private:
  const ::NFMsg::Ident& _internal_invite_target_id() const;
  public:
  const ::NFMsg::Ident& invite_target_id() const;
  ::NFMsg::Ident* release_invite_target_id();
  ::NFMsg::Ident* mutable_invite_target_id();
  void set_allocated_invite_target_id(::NFMsg::Ident* invite_target_id);

  // @@protoc_insertion_point(class_scope:NFMsg.ReqAckInviteTeam)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::NFMsg::Ident* team_id_;
  ::NFMsg::Ident* self_id_;
  ::NFMsg::Ident* invite_target_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NFMsgExtra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ReqTeamEnterEctype : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NFMsg.ReqTeamEnterEctype) */ {
 public:
  ReqTeamEnterEctype();
  virtual ~ReqTeamEnterEctype();

  ReqTeamEnterEctype(const ReqTeamEnterEctype& from);

  inline ReqTeamEnterEctype& operator=(const ReqTeamEnterEctype& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReqTeamEnterEctype(ReqTeamEnterEctype&& from) noexcept
    : ReqTeamEnterEctype() {
    *this = ::std::move(from);
  }

  inline ReqTeamEnterEctype& operator=(ReqTeamEnterEctype&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqTeamEnterEctype& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReqTeamEnterEctype* internal_default_instance() {
    return reinterpret_cast<const ReqTeamEnterEctype*>(
               &_ReqTeamEnterEctype_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(ReqTeamEnterEctype* other);
  friend void swap(ReqTeamEnterEctype& a, ReqTeamEnterEctype& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReqTeamEnterEctype* New() const final {
    return CreateMaybeMessage<ReqTeamEnterEctype>(NULL);
  }

  ReqTeamEnterEctype* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReqTeamEnterEctype>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReqTeamEnterEctype& from);
  void MergeFrom(const ReqTeamEnterEctype& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqTeamEnterEctype* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .NFMsg.Ident team_id = 1;
  bool has_team_id() const;
  void clear_team_id();
  static const int kTeamIdFieldNumber = 1;
  private:
  const ::NFMsg::Ident& _internal_team_id() const;
  public:
  const ::NFMsg::Ident& team_id() const;
  ::NFMsg::Ident* release_team_id();
  ::NFMsg::Ident* mutable_team_id();
  void set_allocated_team_id(::NFMsg::Ident* team_id);

  // .NFMsg.Ident self_id = 2;
  bool has_self_id() const;
  void clear_self_id();
  static const int kSelfIdFieldNumber = 2;
  private:
  const ::NFMsg::Ident& _internal_self_id() const;
  public:
  const ::NFMsg::Ident& self_id() const;
  ::NFMsg::Ident* release_self_id();
  ::NFMsg::Ident* mutable_self_id();
  void set_allocated_self_id(::NFMsg::Ident* self_id);

  // int32 nEctypeID = 3;
  void clear_nectypeid();
  static const int kNEctypeIDFieldNumber = 3;
  ::google::protobuf::int32 nectypeid() const;
  void set_nectypeid(::google::protobuf::int32 value);

  // int32 nGroupID = 4;
  void clear_ngroupid();
  static const int kNGroupIDFieldNumber = 4;
  ::google::protobuf::int32 ngroupid() const;
  void set_ngroupid(::google::protobuf::int32 value);

  // int32 nResult = 5;
  void clear_nresult();
  static const int kNResultFieldNumber = 5;
  ::google::protobuf::int32 nresult() const;
  void set_nresult(::google::protobuf::int32 value);

  // int32 nServerID = 6;
  void clear_nserverid();
  static const int kNServerIDFieldNumber = 6;
  ::google::protobuf::int32 nserverid() const;
  void set_nserverid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:NFMsg.ReqTeamEnterEctype)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::NFMsg::Ident* team_id_;
  ::NFMsg::Ident* self_id_;
  ::google::protobuf::int32 nectypeid_;
  ::google::protobuf::int32 ngroupid_;
  ::google::protobuf::int32 nresult_;
  ::google::protobuf::int32 nserverid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NFMsgExtra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT AckTeamEnterEctype : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NFMsg.AckTeamEnterEctype) */ {
 public:
  AckTeamEnterEctype();
  virtual ~AckTeamEnterEctype();

  AckTeamEnterEctype(const AckTeamEnterEctype& from);

  inline AckTeamEnterEctype& operator=(const AckTeamEnterEctype& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AckTeamEnterEctype(AckTeamEnterEctype&& from) noexcept
    : AckTeamEnterEctype() {
    *this = ::std::move(from);
  }

  inline AckTeamEnterEctype& operator=(AckTeamEnterEctype&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AckTeamEnterEctype& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AckTeamEnterEctype* internal_default_instance() {
    return reinterpret_cast<const AckTeamEnterEctype*>(
               &_AckTeamEnterEctype_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(AckTeamEnterEctype* other);
  friend void swap(AckTeamEnterEctype& a, AckTeamEnterEctype& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AckTeamEnterEctype* New() const final {
    return CreateMaybeMessage<AckTeamEnterEctype>(NULL);
  }

  AckTeamEnterEctype* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AckTeamEnterEctype>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AckTeamEnterEctype& from);
  void MergeFrom(const AckTeamEnterEctype& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AckTeamEnterEctype* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .NFMsg.Ident team_id = 1;
  bool has_team_id() const;
  void clear_team_id();
  static const int kTeamIdFieldNumber = 1;
  private:
  const ::NFMsg::Ident& _internal_team_id() const;
  public:
  const ::NFMsg::Ident& team_id() const;
  ::NFMsg::Ident* release_team_id();
  ::NFMsg::Ident* mutable_team_id();
  void set_allocated_team_id(::NFMsg::Ident* team_id);

  // .NFMsg.Ident self_id = 2;
  bool has_self_id() const;
  void clear_self_id();
  static const int kSelfIdFieldNumber = 2;
  private:
  const ::NFMsg::Ident& _internal_self_id() const;
  public:
  const ::NFMsg::Ident& self_id() const;
  ::NFMsg::Ident* release_self_id();
  ::NFMsg::Ident* mutable_self_id();
  void set_allocated_self_id(::NFMsg::Ident* self_id);

  // int32 nEctypeID = 3;
  void clear_nectypeid();
  static const int kNEctypeIDFieldNumber = 3;
  ::google::protobuf::int32 nectypeid() const;
  void set_nectypeid(::google::protobuf::int32 value);

  // int32 nGroupID = 4;
  void clear_ngroupid();
  static const int kNGroupIDFieldNumber = 4;
  ::google::protobuf::int32 ngroupid() const;
  void set_ngroupid(::google::protobuf::int32 value);

  // int32 nResult = 5;
  void clear_nresult();
  static const int kNResultFieldNumber = 5;
  ::google::protobuf::int32 nresult() const;
  void set_nresult(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:NFMsg.AckTeamEnterEctype)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::NFMsg::Ident* team_id_;
  ::NFMsg::Ident* self_id_;
  ::google::protobuf::int32 nectypeid_;
  ::google::protobuf::int32 ngroupid_;
  ::google::protobuf::int32 nresult_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NFMsgExtra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT GridClanBaseInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NFMsg.GridClanBaseInfo) */ {
 public:
  GridClanBaseInfo();
  virtual ~GridClanBaseInfo();

  GridClanBaseInfo(const GridClanBaseInfo& from);

  inline GridClanBaseInfo& operator=(const GridClanBaseInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GridClanBaseInfo(GridClanBaseInfo&& from) noexcept
    : GridClanBaseInfo() {
    *this = ::std::move(from);
  }

  inline GridClanBaseInfo& operator=(GridClanBaseInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GridClanBaseInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GridClanBaseInfo* internal_default_instance() {
    return reinterpret_cast<const GridClanBaseInfo*>(
               &_GridClanBaseInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(GridClanBaseInfo* other);
  friend void swap(GridClanBaseInfo& a, GridClanBaseInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GridClanBaseInfo* New() const final {
    return CreateMaybeMessage<GridClanBaseInfo>(NULL);
  }

  GridClanBaseInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GridClanBaseInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GridClanBaseInfo& from);
  void MergeFrom(const GridClanBaseInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GridClanBaseInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes icon = 5;
  void clear_icon();
  static const int kIconFieldNumber = 5;
  const ::std::string& icon() const;
  void set_icon(const ::std::string& value);
  #if LANG_CXX11
  void set_icon(::std::string&& value);
  #endif
  void set_icon(const char* value);
  void set_icon(const void* value, size_t size);
  ::std::string* mutable_icon();
  ::std::string* release_icon();
  void set_allocated_icon(::std::string* icon);

  // .NFMsg.Ident id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  private:
  const ::NFMsg::Ident& _internal_id() const;
  public:
  const ::NFMsg::Ident& id() const;
  ::NFMsg::Ident* release_id();
  ::NFMsg::Ident* mutable_id();
  void set_allocated_id(::NFMsg::Ident* id);

  // int32 level = 2;
  void clear_level();
  static const int kLevelFieldNumber = 2;
  ::google::protobuf::int32 level() const;
  void set_level(::google::protobuf::int32 value);

  // int32 count = 3;
  void clear_count();
  static const int kCountFieldNumber = 3;
  ::google::protobuf::int32 count() const;
  void set_count(::google::protobuf::int32 value);

  // int32 resource = 4;
  void clear_resource();
  static const int kResourceFieldNumber = 4;
  ::google::protobuf::int32 resource() const;
  void set_resource(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:NFMsg.GridClanBaseInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr icon_;
  ::NFMsg::Ident* id_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 count_;
  ::google::protobuf::int32 resource_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NFMsgExtra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ReqBigMapGridInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NFMsg.ReqBigMapGridInfo) */ {
 public:
  ReqBigMapGridInfo();
  virtual ~ReqBigMapGridInfo();

  ReqBigMapGridInfo(const ReqBigMapGridInfo& from);

  inline ReqBigMapGridInfo& operator=(const ReqBigMapGridInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReqBigMapGridInfo(ReqBigMapGridInfo&& from) noexcept
    : ReqBigMapGridInfo() {
    *this = ::std::move(from);
  }

  inline ReqBigMapGridInfo& operator=(ReqBigMapGridInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqBigMapGridInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReqBigMapGridInfo* internal_default_instance() {
    return reinterpret_cast<const ReqBigMapGridInfo*>(
               &_ReqBigMapGridInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(ReqBigMapGridInfo* other);
  friend void swap(ReqBigMapGridInfo& a, ReqBigMapGridInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReqBigMapGridInfo* New() const final {
    return CreateMaybeMessage<ReqBigMapGridInfo>(NULL);
  }

  ReqBigMapGridInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReqBigMapGridInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReqBigMapGridInfo& from);
  void MergeFrom(const ReqBigMapGridInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqBigMapGridInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes map_title_id = 1;
  int map_title_id_size() const;
  void clear_map_title_id();
  static const int kMapTitleIdFieldNumber = 1;
  const ::std::string& map_title_id(int index) const;
  ::std::string* mutable_map_title_id(int index);
  void set_map_title_id(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_map_title_id(int index, ::std::string&& value);
  #endif
  void set_map_title_id(int index, const char* value);
  void set_map_title_id(int index, const void* value, size_t size);
  ::std::string* add_map_title_id();
  void add_map_title_id(const ::std::string& value);
  #if LANG_CXX11
  void add_map_title_id(::std::string&& value);
  #endif
  void add_map_title_id(const char* value);
  void add_map_title_id(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& map_title_id() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_map_title_id();

  // @@protoc_insertion_point(class_scope:NFMsg.ReqBigMapGridInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> map_title_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NFMsgExtra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT BigMapGridBaseInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NFMsg.BigMapGridBaseInfo) */ {
 public:
  BigMapGridBaseInfo();
  virtual ~BigMapGridBaseInfo();

  BigMapGridBaseInfo(const BigMapGridBaseInfo& from);

  inline BigMapGridBaseInfo& operator=(const BigMapGridBaseInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BigMapGridBaseInfo(BigMapGridBaseInfo&& from) noexcept
    : BigMapGridBaseInfo() {
    *this = ::std::move(from);
  }

  inline BigMapGridBaseInfo& operator=(BigMapGridBaseInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BigMapGridBaseInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BigMapGridBaseInfo* internal_default_instance() {
    return reinterpret_cast<const BigMapGridBaseInfo*>(
               &_BigMapGridBaseInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(BigMapGridBaseInfo* other);
  friend void swap(BigMapGridBaseInfo& a, BigMapGridBaseInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BigMapGridBaseInfo* New() const final {
    return CreateMaybeMessage<BigMapGridBaseInfo>(NULL);
  }

  BigMapGridBaseInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BigMapGridBaseInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BigMapGridBaseInfo& from);
  void MergeFrom(const BigMapGridBaseInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BigMapGridBaseInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const void* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // .NFMsg.GridClanBaseInfo guild_info = 2;
  bool has_guild_info() const;
  void clear_guild_info();
  static const int kGuildInfoFieldNumber = 2;
  private:
  const ::NFMsg::GridClanBaseInfo& _internal_guild_info() const;
  public:
  const ::NFMsg::GridClanBaseInfo& guild_info() const;
  ::NFMsg::GridClanBaseInfo* release_guild_info();
  ::NFMsg::GridClanBaseInfo* mutable_guild_info();
  void set_allocated_guild_info(::NFMsg::GridClanBaseInfo* guild_info);

  // .NFMsg.Ident kingwarrer = 11;
  bool has_kingwarrer() const;
  void clear_kingwarrer();
  static const int kKingwarrerFieldNumber = 11;
  private:
  const ::NFMsg::Ident& _internal_kingwarrer() const;
  public:
  const ::NFMsg::Ident& kingwarrer() const;
  ::NFMsg::Ident* release_kingwarrer();
  ::NFMsg::Ident* mutable_kingwarrer();
  void set_allocated_kingwarrer(::NFMsg::Ident* kingwarrer);

  // .NFMsg.Ident hurter = 21;
  bool has_hurter() const;
  void clear_hurter();
  static const int kHurterFieldNumber = 21;
  private:
  const ::NFMsg::Ident& _internal_hurter() const;
  public:
  const ::NFMsg::Ident& hurter() const;
  ::NFMsg::Ident* release_hurter();
  ::NFMsg::Ident* mutable_hurter();
  void set_allocated_hurter(::NFMsg::Ident* hurter);

  // int32 kingwar_time = 10;
  void clear_kingwar_time();
  static const int kKingwarTimeFieldNumber = 10;
  ::google::protobuf::int32 kingwar_time() const;
  void set_kingwar_time(::google::protobuf::int32 value);

  // int32 hurting_time = 20;
  void clear_hurting_time();
  static const int kHurtingTimeFieldNumber = 20;
  ::google::protobuf::int32 hurting_time() const;
  void set_hurting_time(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:NFMsg.BigMapGridBaseInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::NFMsg::GridClanBaseInfo* guild_info_;
  ::NFMsg::Ident* kingwarrer_;
  ::NFMsg::Ident* hurter_;
  ::google::protobuf::int32 kingwar_time_;
  ::google::protobuf::int32 hurting_time_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NFMsgExtra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT BigMapLeaveMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NFMsg.BigMapLeaveMsg) */ {
 public:
  BigMapLeaveMsg();
  virtual ~BigMapLeaveMsg();

  BigMapLeaveMsg(const BigMapLeaveMsg& from);

  inline BigMapLeaveMsg& operator=(const BigMapLeaveMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BigMapLeaveMsg(BigMapLeaveMsg&& from) noexcept
    : BigMapLeaveMsg() {
    *this = ::std::move(from);
  }

  inline BigMapLeaveMsg& operator=(BigMapLeaveMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BigMapLeaveMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BigMapLeaveMsg* internal_default_instance() {
    return reinterpret_cast<const BigMapLeaveMsg*>(
               &_BigMapLeaveMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(BigMapLeaveMsg* other);
  friend void swap(BigMapLeaveMsg& a, BigMapLeaveMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BigMapLeaveMsg* New() const final {
    return CreateMaybeMessage<BigMapLeaveMsg>(NULL);
  }

  BigMapLeaveMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BigMapLeaveMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BigMapLeaveMsg& from);
  void MergeFrom(const BigMapLeaveMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BigMapLeaveMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes owner_name = 2;
  void clear_owner_name();
  static const int kOwnerNameFieldNumber = 2;
  const ::std::string& owner_name() const;
  void set_owner_name(const ::std::string& value);
  #if LANG_CXX11
  void set_owner_name(::std::string&& value);
  #endif
  void set_owner_name(const char* value);
  void set_owner_name(const void* value, size_t size);
  ::std::string* mutable_owner_name();
  ::std::string* release_owner_name();
  void set_allocated_owner_name(::std::string* owner_name);

  // bytes msg_data = 3;
  void clear_msg_data();
  static const int kMsgDataFieldNumber = 3;
  const ::std::string& msg_data() const;
  void set_msg_data(const ::std::string& value);
  #if LANG_CXX11
  void set_msg_data(::std::string&& value);
  #endif
  void set_msg_data(const char* value);
  void set_msg_data(const void* value, size_t size);
  ::std::string* mutable_msg_data();
  ::std::string* release_msg_data();
  void set_allocated_msg_data(::std::string* msg_data);

  // .NFMsg.Ident owner = 1;
  bool has_owner() const;
  void clear_owner();
  static const int kOwnerFieldNumber = 1;
  private:
  const ::NFMsg::Ident& _internal_owner() const;
  public:
  const ::NFMsg::Ident& owner() const;
  ::NFMsg::Ident* release_owner();
  ::NFMsg::Ident* mutable_owner();
  void set_allocated_owner(::NFMsg::Ident* owner);

  // int32 msg_time = 4;
  void clear_msg_time();
  static const int kMsgTimeFieldNumber = 4;
  ::google::protobuf::int32 msg_time() const;
  void set_msg_time(::google::protobuf::int32 value);

  // int32 owner_level = 5;
  void clear_owner_level();
  static const int kOwnerLevelFieldNumber = 5;
  ::google::protobuf::int32 owner_level() const;
  void set_owner_level(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:NFMsg.BigMapLeaveMsg)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr owner_name_;
  ::google::protobuf::internal::ArenaStringPtr msg_data_;
  ::NFMsg::Ident* owner_;
  ::google::protobuf::int32 msg_time_;
  ::google::protobuf::int32 owner_level_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NFMsgExtra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT BigMapWarHistory : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NFMsg.BigMapWarHistory) */ {
 public:
  BigMapWarHistory();
  virtual ~BigMapWarHistory();

  BigMapWarHistory(const BigMapWarHistory& from);

  inline BigMapWarHistory& operator=(const BigMapWarHistory& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BigMapWarHistory(BigMapWarHistory&& from) noexcept
    : BigMapWarHistory() {
    *this = ::std::move(from);
  }

  inline BigMapWarHistory& operator=(BigMapWarHistory&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BigMapWarHistory& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BigMapWarHistory* internal_default_instance() {
    return reinterpret_cast<const BigMapWarHistory*>(
               &_BigMapWarHistory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(BigMapWarHistory* other);
  friend void swap(BigMapWarHistory& a, BigMapWarHistory& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BigMapWarHistory* New() const final {
    return CreateMaybeMessage<BigMapWarHistory>(NULL);
  }

  BigMapWarHistory* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BigMapWarHistory>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BigMapWarHistory& from);
  void MergeFrom(const BigMapWarHistory& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BigMapWarHistory* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .NFMsg.GridClanBaseInfo red_info = 1;
  bool has_red_info() const;
  void clear_red_info();
  static const int kRedInfoFieldNumber = 1;
  private:
  const ::NFMsg::GridClanBaseInfo& _internal_red_info() const;
  public:
  const ::NFMsg::GridClanBaseInfo& red_info() const;
  ::NFMsg::GridClanBaseInfo* release_red_info();
  ::NFMsg::GridClanBaseInfo* mutable_red_info();
  void set_allocated_red_info(::NFMsg::GridClanBaseInfo* red_info);

  // .NFMsg.GridClanBaseInfo blue_info = 2;
  bool has_blue_info() const;
  void clear_blue_info();
  static const int kBlueInfoFieldNumber = 2;
  private:
  const ::NFMsg::GridClanBaseInfo& _internal_blue_info() const;
  public:
  const ::NFMsg::GridClanBaseInfo& blue_info() const;
  ::NFMsg::GridClanBaseInfo* release_blue_info();
  ::NFMsg::GridClanBaseInfo* mutable_blue_info();
  void set_allocated_blue_info(::NFMsg::GridClanBaseInfo* blue_info);

  // .NFMsg.Ident winner_id = 10;
  bool has_winner_id() const;
  void clear_winner_id();
  static const int kWinnerIdFieldNumber = 10;
  private:
  const ::NFMsg::Ident& _internal_winner_id() const;
  public:
  const ::NFMsg::Ident& winner_id() const;
  ::NFMsg::Ident* release_winner_id();
  ::NFMsg::Ident* mutable_winner_id();
  void set_allocated_winner_id(::NFMsg::Ident* winner_id);

  // int32 war_time = 11;
  void clear_war_time();
  static const int kWarTimeFieldNumber = 11;
  ::google::protobuf::int32 war_time() const;
  void set_war_time(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:NFMsg.BigMapWarHistory)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::NFMsg::GridClanBaseInfo* red_info_;
  ::NFMsg::GridClanBaseInfo* blue_info_;
  ::NFMsg::Ident* winner_id_;
  ::google::protobuf::int32 war_time_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NFMsgExtra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT BigMapGridDetailInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NFMsg.BigMapGridDetailInfo) */ {
 public:
  BigMapGridDetailInfo();
  virtual ~BigMapGridDetailInfo();

  BigMapGridDetailInfo(const BigMapGridDetailInfo& from);

  inline BigMapGridDetailInfo& operator=(const BigMapGridDetailInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BigMapGridDetailInfo(BigMapGridDetailInfo&& from) noexcept
    : BigMapGridDetailInfo() {
    *this = ::std::move(from);
  }

  inline BigMapGridDetailInfo& operator=(BigMapGridDetailInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BigMapGridDetailInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BigMapGridDetailInfo* internal_default_instance() {
    return reinterpret_cast<const BigMapGridDetailInfo*>(
               &_BigMapGridDetailInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(BigMapGridDetailInfo* other);
  friend void swap(BigMapGridDetailInfo& a, BigMapGridDetailInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BigMapGridDetailInfo* New() const final {
    return CreateMaybeMessage<BigMapGridDetailInfo>(NULL);
  }

  BigMapGridDetailInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BigMapGridDetailInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BigMapGridDetailInfo& from);
  void MergeFrom(const BigMapGridDetailInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BigMapGridDetailInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .NFMsg.GridClanBaseInfo stay_guid_list = 2;
  int stay_guid_list_size() const;
  void clear_stay_guid_list();
  static const int kStayGuidListFieldNumber = 2;
  ::NFMsg::GridClanBaseInfo* mutable_stay_guid_list(int index);
  ::google::protobuf::RepeatedPtrField< ::NFMsg::GridClanBaseInfo >*
      mutable_stay_guid_list();
  const ::NFMsg::GridClanBaseInfo& stay_guid_list(int index) const;
  ::NFMsg::GridClanBaseInfo* add_stay_guid_list();
  const ::google::protobuf::RepeatedPtrField< ::NFMsg::GridClanBaseInfo >&
      stay_guid_list() const;

  // repeated .NFMsg.BigMapLeaveMsg leave_msg = 3;
  int leave_msg_size() const;
  void clear_leave_msg();
  static const int kLeaveMsgFieldNumber = 3;
  ::NFMsg::BigMapLeaveMsg* mutable_leave_msg(int index);
  ::google::protobuf::RepeatedPtrField< ::NFMsg::BigMapLeaveMsg >*
      mutable_leave_msg();
  const ::NFMsg::BigMapLeaveMsg& leave_msg(int index) const;
  ::NFMsg::BigMapLeaveMsg* add_leave_msg();
  const ::google::protobuf::RepeatedPtrField< ::NFMsg::BigMapLeaveMsg >&
      leave_msg() const;

  // repeated .NFMsg.BigMapWarHistory war_history = 4;
  int war_history_size() const;
  void clear_war_history();
  static const int kWarHistoryFieldNumber = 4;
  ::NFMsg::BigMapWarHistory* mutable_war_history(int index);
  ::google::protobuf::RepeatedPtrField< ::NFMsg::BigMapWarHistory >*
      mutable_war_history();
  const ::NFMsg::BigMapWarHistory& war_history(int index) const;
  ::NFMsg::BigMapWarHistory* add_war_history();
  const ::google::protobuf::RepeatedPtrField< ::NFMsg::BigMapWarHistory >&
      war_history() const;

  // .NFMsg.BigMapGridBaseInfo grid_base_info = 1;
  bool has_grid_base_info() const;
  void clear_grid_base_info();
  static const int kGridBaseInfoFieldNumber = 1;
  private:
  const ::NFMsg::BigMapGridBaseInfo& _internal_grid_base_info() const;
  public:
  const ::NFMsg::BigMapGridBaseInfo& grid_base_info() const;
  ::NFMsg::BigMapGridBaseInfo* release_grid_base_info();
  ::NFMsg::BigMapGridBaseInfo* mutable_grid_base_info();
  void set_allocated_grid_base_info(::NFMsg::BigMapGridBaseInfo* grid_base_info);

  // @@protoc_insertion_point(class_scope:NFMsg.BigMapGridDetailInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::NFMsg::GridClanBaseInfo > stay_guid_list_;
  ::google::protobuf::RepeatedPtrField< ::NFMsg::BigMapLeaveMsg > leave_msg_;
  ::google::protobuf::RepeatedPtrField< ::NFMsg::BigMapWarHistory > war_history_;
  ::NFMsg::BigMapGridBaseInfo* grid_base_info_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NFMsgExtra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT AckBigMapGridInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NFMsg.AckBigMapGridInfo) */ {
 public:
  AckBigMapGridInfo();
  virtual ~AckBigMapGridInfo();

  AckBigMapGridInfo(const AckBigMapGridInfo& from);

  inline AckBigMapGridInfo& operator=(const AckBigMapGridInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AckBigMapGridInfo(AckBigMapGridInfo&& from) noexcept
    : AckBigMapGridInfo() {
    *this = ::std::move(from);
  }

  inline AckBigMapGridInfo& operator=(AckBigMapGridInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AckBigMapGridInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AckBigMapGridInfo* internal_default_instance() {
    return reinterpret_cast<const AckBigMapGridInfo*>(
               &_AckBigMapGridInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(AckBigMapGridInfo* other);
  friend void swap(AckBigMapGridInfo& a, AckBigMapGridInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AckBigMapGridInfo* New() const final {
    return CreateMaybeMessage<AckBigMapGridInfo>(NULL);
  }

  AckBigMapGridInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AckBigMapGridInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AckBigMapGridInfo& from);
  void MergeFrom(const AckBigMapGridInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AckBigMapGridInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .NFMsg.BigMapGridDetailInfo map_data = 1;
  int map_data_size() const;
  void clear_map_data();
  static const int kMapDataFieldNumber = 1;
  ::NFMsg::BigMapGridDetailInfo* mutable_map_data(int index);
  ::google::protobuf::RepeatedPtrField< ::NFMsg::BigMapGridDetailInfo >*
      mutable_map_data();
  const ::NFMsg::BigMapGridDetailInfo& map_data(int index) const;
  ::NFMsg::BigMapGridDetailInfo* add_map_data();
  const ::google::protobuf::RepeatedPtrField< ::NFMsg::BigMapGridDetailInfo >&
      map_data() const;

  // @@protoc_insertion_point(class_scope:NFMsg.AckBigMapGridInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::NFMsg::BigMapGridDetailInfo > map_data_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NFMsgExtra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ReqBigMapInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NFMsg.ReqBigMapInfo) */ {
 public:
  ReqBigMapInfo();
  virtual ~ReqBigMapInfo();

  ReqBigMapInfo(const ReqBigMapInfo& from);

  inline ReqBigMapInfo& operator=(const ReqBigMapInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReqBigMapInfo(ReqBigMapInfo&& from) noexcept
    : ReqBigMapInfo() {
    *this = ::std::move(from);
  }

  inline ReqBigMapInfo& operator=(ReqBigMapInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqBigMapInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReqBigMapInfo* internal_default_instance() {
    return reinterpret_cast<const ReqBigMapInfo*>(
               &_ReqBigMapInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(ReqBigMapInfo* other);
  friend void swap(ReqBigMapInfo& a, ReqBigMapInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReqBigMapInfo* New() const final {
    return CreateMaybeMessage<ReqBigMapInfo>(NULL);
  }

  ReqBigMapInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReqBigMapInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReqBigMapInfo& from);
  void MergeFrom(const ReqBigMapInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqBigMapInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:NFMsg.ReqBigMapInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NFMsgExtra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT AckBigMapInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NFMsg.AckBigMapInfo) */ {
 public:
  AckBigMapInfo();
  virtual ~AckBigMapInfo();

  AckBigMapInfo(const AckBigMapInfo& from);

  inline AckBigMapInfo& operator=(const AckBigMapInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AckBigMapInfo(AckBigMapInfo&& from) noexcept
    : AckBigMapInfo() {
    *this = ::std::move(from);
  }

  inline AckBigMapInfo& operator=(AckBigMapInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AckBigMapInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AckBigMapInfo* internal_default_instance() {
    return reinterpret_cast<const AckBigMapInfo*>(
               &_AckBigMapInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(AckBigMapInfo* other);
  friend void swap(AckBigMapInfo& a, AckBigMapInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AckBigMapInfo* New() const final {
    return CreateMaybeMessage<AckBigMapInfo>(NULL);
  }

  AckBigMapInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AckBigMapInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AckBigMapInfo& from);
  void MergeFrom(const AckBigMapInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AckBigMapInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .NFMsg.BigMapGridBaseInfo grid_base_info = 1;
  int grid_base_info_size() const;
  void clear_grid_base_info();
  static const int kGridBaseInfoFieldNumber = 1;
  ::NFMsg::BigMapGridBaseInfo* mutable_grid_base_info(int index);
  ::google::protobuf::RepeatedPtrField< ::NFMsg::BigMapGridBaseInfo >*
      mutable_grid_base_info();
  const ::NFMsg::BigMapGridBaseInfo& grid_base_info(int index) const;
  ::NFMsg::BigMapGridBaseInfo* add_grid_base_info();
  const ::google::protobuf::RepeatedPtrField< ::NFMsg::BigMapGridBaseInfo >&
      grid_base_info() const;

  // @@protoc_insertion_point(class_scope:NFMsg.AckBigMapInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::NFMsg::BigMapGridBaseInfo > grid_base_info_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NFMsgExtra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ReqHoldMapGrid : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NFMsg.ReqHoldMapGrid) */ {
 public:
  ReqHoldMapGrid();
  virtual ~ReqHoldMapGrid();

  ReqHoldMapGrid(const ReqHoldMapGrid& from);

  inline ReqHoldMapGrid& operator=(const ReqHoldMapGrid& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReqHoldMapGrid(ReqHoldMapGrid&& from) noexcept
    : ReqHoldMapGrid() {
    *this = ::std::move(from);
  }

  inline ReqHoldMapGrid& operator=(ReqHoldMapGrid&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqHoldMapGrid& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReqHoldMapGrid* internal_default_instance() {
    return reinterpret_cast<const ReqHoldMapGrid*>(
               &_ReqHoldMapGrid_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(ReqHoldMapGrid* other);
  friend void swap(ReqHoldMapGrid& a, ReqHoldMapGrid& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReqHoldMapGrid* New() const final {
    return CreateMaybeMessage<ReqHoldMapGrid>(NULL);
  }

  ReqHoldMapGrid* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReqHoldMapGrid>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReqHoldMapGrid& from);
  void MergeFrom(const ReqHoldMapGrid& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqHoldMapGrid* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes map_title_id = 1;
  void clear_map_title_id();
  static const int kMapTitleIdFieldNumber = 1;
  const ::std::string& map_title_id() const;
  void set_map_title_id(const ::std::string& value);
  #if LANG_CXX11
  void set_map_title_id(::std::string&& value);
  #endif
  void set_map_title_id(const char* value);
  void set_map_title_id(const void* value, size_t size);
  ::std::string* mutable_map_title_id();
  ::std::string* release_map_title_id();
  void set_allocated_map_title_id(::std::string* map_title_id);

  // .NFMsg.Ident guild_id = 2;
  bool has_guild_id() const;
  void clear_guild_id();
  static const int kGuildIdFieldNumber = 2;
  private:
  const ::NFMsg::Ident& _internal_guild_id() const;
  public:
  const ::NFMsg::Ident& guild_id() const;
  ::NFMsg::Ident* release_guild_id();
  ::NFMsg::Ident* mutable_guild_id();
  void set_allocated_guild_id(::NFMsg::Ident* guild_id);

  // @@protoc_insertion_point(class_scope:NFMsg.ReqHoldMapGrid)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr map_title_id_;
  ::NFMsg::Ident* guild_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NFMsgExtra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT AckHoldMapGrid : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NFMsg.AckHoldMapGrid) */ {
 public:
  AckHoldMapGrid();
  virtual ~AckHoldMapGrid();

  AckHoldMapGrid(const AckHoldMapGrid& from);

  inline AckHoldMapGrid& operator=(const AckHoldMapGrid& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AckHoldMapGrid(AckHoldMapGrid&& from) noexcept
    : AckHoldMapGrid() {
    *this = ::std::move(from);
  }

  inline AckHoldMapGrid& operator=(AckHoldMapGrid&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AckHoldMapGrid& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AckHoldMapGrid* internal_default_instance() {
    return reinterpret_cast<const AckHoldMapGrid*>(
               &_AckHoldMapGrid_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(AckHoldMapGrid* other);
  friend void swap(AckHoldMapGrid& a, AckHoldMapGrid& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AckHoldMapGrid* New() const final {
    return CreateMaybeMessage<AckHoldMapGrid>(NULL);
  }

  AckHoldMapGrid* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AckHoldMapGrid>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AckHoldMapGrid& from);
  void MergeFrom(const AckHoldMapGrid& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AckHoldMapGrid* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:NFMsg.AckHoldMapGrid)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NFMsgExtra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ReqLeaveMapMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NFMsg.ReqLeaveMapMsg) */ {
 public:
  ReqLeaveMapMsg();
  virtual ~ReqLeaveMapMsg();

  ReqLeaveMapMsg(const ReqLeaveMapMsg& from);

  inline ReqLeaveMapMsg& operator=(const ReqLeaveMapMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReqLeaveMapMsg(ReqLeaveMapMsg&& from) noexcept
    : ReqLeaveMapMsg() {
    *this = ::std::move(from);
  }

  inline ReqLeaveMapMsg& operator=(ReqLeaveMapMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqLeaveMapMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReqLeaveMapMsg* internal_default_instance() {
    return reinterpret_cast<const ReqLeaveMapMsg*>(
               &_ReqLeaveMapMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(ReqLeaveMapMsg* other);
  friend void swap(ReqLeaveMapMsg& a, ReqLeaveMapMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReqLeaveMapMsg* New() const final {
    return CreateMaybeMessage<ReqLeaveMapMsg>(NULL);
  }

  ReqLeaveMapMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReqLeaveMapMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReqLeaveMapMsg& from);
  void MergeFrom(const ReqLeaveMapMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqLeaveMapMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes map_title_id = 1;
  void clear_map_title_id();
  static const int kMapTitleIdFieldNumber = 1;
  const ::std::string& map_title_id() const;
  void set_map_title_id(const ::std::string& value);
  #if LANG_CXX11
  void set_map_title_id(::std::string&& value);
  #endif
  void set_map_title_id(const char* value);
  void set_map_title_id(const void* value, size_t size);
  ::std::string* mutable_map_title_id();
  ::std::string* release_map_title_id();
  void set_allocated_map_title_id(::std::string* map_title_id);

  // .NFMsg.BigMapLeaveMsg leave_msg = 2;
  bool has_leave_msg() const;
  void clear_leave_msg();
  static const int kLeaveMsgFieldNumber = 2;
  private:
  const ::NFMsg::BigMapLeaveMsg& _internal_leave_msg() const;
  public:
  const ::NFMsg::BigMapLeaveMsg& leave_msg() const;
  ::NFMsg::BigMapLeaveMsg* release_leave_msg();
  ::NFMsg::BigMapLeaveMsg* mutable_leave_msg();
  void set_allocated_leave_msg(::NFMsg::BigMapLeaveMsg* leave_msg);

  // @@protoc_insertion_point(class_scope:NFMsg.ReqLeaveMapMsg)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr map_title_id_;
  ::NFMsg::BigMapLeaveMsg* leave_msg_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NFMsgExtra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT AckLeaveMapMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NFMsg.AckLeaveMapMsg) */ {
 public:
  AckLeaveMapMsg();
  virtual ~AckLeaveMapMsg();

  AckLeaveMapMsg(const AckLeaveMapMsg& from);

  inline AckLeaveMapMsg& operator=(const AckLeaveMapMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AckLeaveMapMsg(AckLeaveMapMsg&& from) noexcept
    : AckLeaveMapMsg() {
    *this = ::std::move(from);
  }

  inline AckLeaveMapMsg& operator=(AckLeaveMapMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AckLeaveMapMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AckLeaveMapMsg* internal_default_instance() {
    return reinterpret_cast<const AckLeaveMapMsg*>(
               &_AckLeaveMapMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(AckLeaveMapMsg* other);
  friend void swap(AckLeaveMapMsg& a, AckLeaveMapMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AckLeaveMapMsg* New() const final {
    return CreateMaybeMessage<AckLeaveMapMsg>(NULL);
  }

  AckLeaveMapMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AckLeaveMapMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AckLeaveMapMsg& from);
  void MergeFrom(const AckLeaveMapMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AckLeaveMapMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:NFMsg.AckLeaveMapMsg)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NFMsgExtra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ReqGetMapAward : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NFMsg.ReqGetMapAward) */ {
 public:
  ReqGetMapAward();
  virtual ~ReqGetMapAward();

  ReqGetMapAward(const ReqGetMapAward& from);

  inline ReqGetMapAward& operator=(const ReqGetMapAward& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReqGetMapAward(ReqGetMapAward&& from) noexcept
    : ReqGetMapAward() {
    *this = ::std::move(from);
  }

  inline ReqGetMapAward& operator=(ReqGetMapAward&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqGetMapAward& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReqGetMapAward* internal_default_instance() {
    return reinterpret_cast<const ReqGetMapAward*>(
               &_ReqGetMapAward_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(ReqGetMapAward* other);
  friend void swap(ReqGetMapAward& a, ReqGetMapAward& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReqGetMapAward* New() const final {
    return CreateMaybeMessage<ReqGetMapAward>(NULL);
  }

  ReqGetMapAward* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReqGetMapAward>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReqGetMapAward& from);
  void MergeFrom(const ReqGetMapAward& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqGetMapAward* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes map_title_id = 1;
  void clear_map_title_id();
  static const int kMapTitleIdFieldNumber = 1;
  const ::std::string& map_title_id() const;
  void set_map_title_id(const ::std::string& value);
  #if LANG_CXX11
  void set_map_title_id(::std::string&& value);
  #endif
  void set_map_title_id(const char* value);
  void set_map_title_id(const void* value, size_t size);
  ::std::string* mutable_map_title_id();
  ::std::string* release_map_title_id();
  void set_allocated_map_title_id(::std::string* map_title_id);

  // @@protoc_insertion_point(class_scope:NFMsg.ReqGetMapAward)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr map_title_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NFMsgExtra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT AckGetMapAward : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NFMsg.AckGetMapAward) */ {
 public:
  AckGetMapAward();
  virtual ~AckGetMapAward();

  AckGetMapAward(const AckGetMapAward& from);

  inline AckGetMapAward& operator=(const AckGetMapAward& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AckGetMapAward(AckGetMapAward&& from) noexcept
    : AckGetMapAward() {
    *this = ::std::move(from);
  }

  inline AckGetMapAward& operator=(AckGetMapAward&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AckGetMapAward& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AckGetMapAward* internal_default_instance() {
    return reinterpret_cast<const AckGetMapAward*>(
               &_AckGetMapAward_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(AckGetMapAward* other);
  friend void swap(AckGetMapAward& a, AckGetMapAward& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AckGetMapAward* New() const final {
    return CreateMaybeMessage<AckGetMapAward>(NULL);
  }

  AckGetMapAward* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AckGetMapAward>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AckGetMapAward& from);
  void MergeFrom(const AckGetMapAward& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AckGetMapAward* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:NFMsg.AckGetMapAward)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NFMsgExtra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ReqMapHunting : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NFMsg.ReqMapHunting) */ {
 public:
  ReqMapHunting();
  virtual ~ReqMapHunting();

  ReqMapHunting(const ReqMapHunting& from);

  inline ReqMapHunting& operator=(const ReqMapHunting& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReqMapHunting(ReqMapHunting&& from) noexcept
    : ReqMapHunting() {
    *this = ::std::move(from);
  }

  inline ReqMapHunting& operator=(ReqMapHunting&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqMapHunting& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReqMapHunting* internal_default_instance() {
    return reinterpret_cast<const ReqMapHunting*>(
               &_ReqMapHunting_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  void Swap(ReqMapHunting* other);
  friend void swap(ReqMapHunting& a, ReqMapHunting& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReqMapHunting* New() const final {
    return CreateMaybeMessage<ReqMapHunting>(NULL);
  }

  ReqMapHunting* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReqMapHunting>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReqMapHunting& from);
  void MergeFrom(const ReqMapHunting& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqMapHunting* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes map_title_id = 1;
  void clear_map_title_id();
  static const int kMapTitleIdFieldNumber = 1;
  const ::std::string& map_title_id() const;
  void set_map_title_id(const ::std::string& value);
  #if LANG_CXX11
  void set_map_title_id(::std::string&& value);
  #endif
  void set_map_title_id(const char* value);
  void set_map_title_id(const void* value, size_t size);
  ::std::string* mutable_map_title_id();
  ::std::string* release_map_title_id();
  void set_allocated_map_title_id(::std::string* map_title_id);

  // @@protoc_insertion_point(class_scope:NFMsg.ReqMapHunting)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr map_title_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NFMsgExtra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT AckMapHunting : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NFMsg.AckMapHunting) */ {
 public:
  AckMapHunting();
  virtual ~AckMapHunting();

  AckMapHunting(const AckMapHunting& from);

  inline AckMapHunting& operator=(const AckMapHunting& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AckMapHunting(AckMapHunting&& from) noexcept
    : AckMapHunting() {
    *this = ::std::move(from);
  }

  inline AckMapHunting& operator=(AckMapHunting&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AckMapHunting& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AckMapHunting* internal_default_instance() {
    return reinterpret_cast<const AckMapHunting*>(
               &_AckMapHunting_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  void Swap(AckMapHunting* other);
  friend void swap(AckMapHunting& a, AckMapHunting& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AckMapHunting* New() const final {
    return CreateMaybeMessage<AckMapHunting>(NULL);
  }

  AckMapHunting* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AckMapHunting>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AckMapHunting& from);
  void MergeFrom(const AckMapHunting& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AckMapHunting* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:NFMsg.AckMapHunting)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NFMsgExtra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ReqMapKingWar : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NFMsg.ReqMapKingWar) */ {
 public:
  ReqMapKingWar();
  virtual ~ReqMapKingWar();

  ReqMapKingWar(const ReqMapKingWar& from);

  inline ReqMapKingWar& operator=(const ReqMapKingWar& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReqMapKingWar(ReqMapKingWar&& from) noexcept
    : ReqMapKingWar() {
    *this = ::std::move(from);
  }

  inline ReqMapKingWar& operator=(ReqMapKingWar&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqMapKingWar& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReqMapKingWar* internal_default_instance() {
    return reinterpret_cast<const ReqMapKingWar*>(
               &_ReqMapKingWar_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  void Swap(ReqMapKingWar* other);
  friend void swap(ReqMapKingWar& a, ReqMapKingWar& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReqMapKingWar* New() const final {
    return CreateMaybeMessage<ReqMapKingWar>(NULL);
  }

  ReqMapKingWar* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReqMapKingWar>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReqMapKingWar& from);
  void MergeFrom(const ReqMapKingWar& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqMapKingWar* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes map_title = 1;
  void clear_map_title();
  static const int kMapTitleFieldNumber = 1;
  const ::std::string& map_title() const;
  void set_map_title(const ::std::string& value);
  #if LANG_CXX11
  void set_map_title(::std::string&& value);
  #endif
  void set_map_title(const char* value);
  void set_map_title(const void* value, size_t size);
  ::std::string* mutable_map_title();
  ::std::string* release_map_title();
  void set_allocated_map_title(::std::string* map_title);

  // @@protoc_insertion_point(class_scope:NFMsg.ReqMapKingWar)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr map_title_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NFMsgExtra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT AckMapKingWar : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NFMsg.AckMapKingWar) */ {
 public:
  AckMapKingWar();
  virtual ~AckMapKingWar();

  AckMapKingWar(const AckMapKingWar& from);

  inline AckMapKingWar& operator=(const AckMapKingWar& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AckMapKingWar(AckMapKingWar&& from) noexcept
    : AckMapKingWar() {
    *this = ::std::move(from);
  }

  inline AckMapKingWar& operator=(AckMapKingWar&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AckMapKingWar& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AckMapKingWar* internal_default_instance() {
    return reinterpret_cast<const AckMapKingWar*>(
               &_AckMapKingWar_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  void Swap(AckMapKingWar* other);
  friend void swap(AckMapKingWar& a, AckMapKingWar& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AckMapKingWar* New() const final {
    return CreateMaybeMessage<AckMapKingWar>(NULL);
  }

  AckMapKingWar* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AckMapKingWar>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AckMapKingWar& from);
  void MergeFrom(const AckMapKingWar& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AckMapKingWar* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes map_title = 1;
  void clear_map_title();
  static const int kMapTitleFieldNumber = 1;
  const ::std::string& map_title() const;
  void set_map_title(const ::std::string& value);
  #if LANG_CXX11
  void set_map_title(::std::string&& value);
  #endif
  void set_map_title(const char* value);
  void set_map_title(const void* value, size_t size);
  ::std::string* mutable_map_title();
  ::std::string* release_map_title();
  void set_allocated_map_title(::std::string* map_title);

  // @@protoc_insertion_point(class_scope:NFMsg.AckMapKingWar)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr map_title_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NFMsgExtra_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ReqAIOnwer

// .NFMsg.Ident ai_id = 1;
inline bool ReqAIOnwer::has_ai_id() const {
  return this != internal_default_instance() && ai_id_ != NULL;
}
inline const ::NFMsg::Ident& ReqAIOnwer::_internal_ai_id() const {
  return *ai_id_;
}
inline const ::NFMsg::Ident& ReqAIOnwer::ai_id() const {
  const ::NFMsg::Ident* p = ai_id_;
  // @@protoc_insertion_point(field_get:NFMsg.ReqAIOnwer.ai_id)
  return p != NULL ? *p : *reinterpret_cast<const ::NFMsg::Ident*>(
      &::NFMsg::_Ident_default_instance_);
}
inline ::NFMsg::Ident* ReqAIOnwer::release_ai_id() {
  // @@protoc_insertion_point(field_release:NFMsg.ReqAIOnwer.ai_id)
  
  ::NFMsg::Ident* temp = ai_id_;
  ai_id_ = NULL;
  return temp;
}
inline ::NFMsg::Ident* ReqAIOnwer::mutable_ai_id() {
  
  if (ai_id_ == NULL) {
    auto* p = CreateMaybeMessage<::NFMsg::Ident>(GetArenaNoVirtual());
    ai_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:NFMsg.ReqAIOnwer.ai_id)
  return ai_id_;
}
inline void ReqAIOnwer::set_allocated_ai_id(::NFMsg::Ident* ai_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(ai_id_);
  }
  if (ai_id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      ai_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ai_id, submessage_arena);
    }
    
  } else {
    
  }
  ai_id_ = ai_id;
  // @@protoc_insertion_point(field_set_allocated:NFMsg.ReqAIOnwer.ai_id)
}

// -------------------------------------------------------------------

// TeamInfo

// .NFMsg.Ident team_id = 1;
inline bool TeamInfo::has_team_id() const {
  return this != internal_default_instance() && team_id_ != NULL;
}
inline const ::NFMsg::Ident& TeamInfo::_internal_team_id() const {
  return *team_id_;
}
inline const ::NFMsg::Ident& TeamInfo::team_id() const {
  const ::NFMsg::Ident* p = team_id_;
  // @@protoc_insertion_point(field_get:NFMsg.TeamInfo.team_id)
  return p != NULL ? *p : *reinterpret_cast<const ::NFMsg::Ident*>(
      &::NFMsg::_Ident_default_instance_);
}
inline ::NFMsg::Ident* TeamInfo::release_team_id() {
  // @@protoc_insertion_point(field_release:NFMsg.TeamInfo.team_id)
  
  ::NFMsg::Ident* temp = team_id_;
  team_id_ = NULL;
  return temp;
}
inline ::NFMsg::Ident* TeamInfo::mutable_team_id() {
  
  if (team_id_ == NULL) {
    auto* p = CreateMaybeMessage<::NFMsg::Ident>(GetArenaNoVirtual());
    team_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:NFMsg.TeamInfo.team_id)
  return team_id_;
}
inline void TeamInfo::set_allocated_team_id(::NFMsg::Ident* team_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(team_id_);
  }
  if (team_id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      team_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, team_id, submessage_arena);
    }
    
  } else {
    
  }
  team_id_ = team_id;
  // @@protoc_insertion_point(field_set_allocated:NFMsg.TeamInfo.team_id)
}

// .NFMsg.Ident captain_id = 2;
inline bool TeamInfo::has_captain_id() const {
  return this != internal_default_instance() && captain_id_ != NULL;
}
inline const ::NFMsg::Ident& TeamInfo::_internal_captain_id() const {
  return *captain_id_;
}
inline const ::NFMsg::Ident& TeamInfo::captain_id() const {
  const ::NFMsg::Ident* p = captain_id_;
  // @@protoc_insertion_point(field_get:NFMsg.TeamInfo.captain_id)
  return p != NULL ? *p : *reinterpret_cast<const ::NFMsg::Ident*>(
      &::NFMsg::_Ident_default_instance_);
}
inline ::NFMsg::Ident* TeamInfo::release_captain_id() {
  // @@protoc_insertion_point(field_release:NFMsg.TeamInfo.captain_id)
  
  ::NFMsg::Ident* temp = captain_id_;
  captain_id_ = NULL;
  return temp;
}
inline ::NFMsg::Ident* TeamInfo::mutable_captain_id() {
  
  if (captain_id_ == NULL) {
    auto* p = CreateMaybeMessage<::NFMsg::Ident>(GetArenaNoVirtual());
    captain_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:NFMsg.TeamInfo.captain_id)
  return captain_id_;
}
inline void TeamInfo::set_allocated_captain_id(::NFMsg::Ident* captain_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(captain_id_);
  }
  if (captain_id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      captain_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, captain_id, submessage_arena);
    }
    
  } else {
    
  }
  captain_id_ = captain_id;
  // @@protoc_insertion_point(field_set_allocated:NFMsg.TeamInfo.captain_id)
}

// repeated .NFMsg.TeammemberInfo teammemberInfo = 3;
inline int TeamInfo::teammemberinfo_size() const {
  return teammemberinfo_.size();
}
inline void TeamInfo::clear_teammemberinfo() {
  teammemberinfo_.Clear();
}
inline ::NFMsg::TeammemberInfo* TeamInfo::mutable_teammemberinfo(int index) {
  // @@protoc_insertion_point(field_mutable:NFMsg.TeamInfo.teammemberInfo)
  return teammemberinfo_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NFMsg::TeammemberInfo >*
TeamInfo::mutable_teammemberinfo() {
  // @@protoc_insertion_point(field_mutable_list:NFMsg.TeamInfo.teammemberInfo)
  return &teammemberinfo_;
}
inline const ::NFMsg::TeammemberInfo& TeamInfo::teammemberinfo(int index) const {
  // @@protoc_insertion_point(field_get:NFMsg.TeamInfo.teammemberInfo)
  return teammemberinfo_.Get(index);
}
inline ::NFMsg::TeammemberInfo* TeamInfo::add_teammemberinfo() {
  // @@protoc_insertion_point(field_add:NFMsg.TeamInfo.teammemberInfo)
  return teammemberinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NFMsg::TeammemberInfo >&
TeamInfo::teammemberinfo() const {
  // @@protoc_insertion_point(field_list:NFMsg.TeamInfo.teammemberInfo)
  return teammemberinfo_;
}

// -------------------------------------------------------------------

// TeammemberInfo

// .NFMsg.Ident player_id = 1;
inline bool TeammemberInfo::has_player_id() const {
  return this != internal_default_instance() && player_id_ != NULL;
}
inline const ::NFMsg::Ident& TeammemberInfo::_internal_player_id() const {
  return *player_id_;
}
inline const ::NFMsg::Ident& TeammemberInfo::player_id() const {
  const ::NFMsg::Ident* p = player_id_;
  // @@protoc_insertion_point(field_get:NFMsg.TeammemberInfo.player_id)
  return p != NULL ? *p : *reinterpret_cast<const ::NFMsg::Ident*>(
      &::NFMsg::_Ident_default_instance_);
}
inline ::NFMsg::Ident* TeammemberInfo::release_player_id() {
  // @@protoc_insertion_point(field_release:NFMsg.TeammemberInfo.player_id)
  
  ::NFMsg::Ident* temp = player_id_;
  player_id_ = NULL;
  return temp;
}
inline ::NFMsg::Ident* TeammemberInfo::mutable_player_id() {
  
  if (player_id_ == NULL) {
    auto* p = CreateMaybeMessage<::NFMsg::Ident>(GetArenaNoVirtual());
    player_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:NFMsg.TeammemberInfo.player_id)
  return player_id_;
}
inline void TeammemberInfo::set_allocated_player_id(::NFMsg::Ident* player_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(player_id_);
  }
  if (player_id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      player_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, player_id, submessage_arena);
    }
    
  } else {
    
  }
  player_id_ = player_id;
  // @@protoc_insertion_point(field_set_allocated:NFMsg.TeammemberInfo.player_id)
}

// string name = 2;
inline void TeammemberInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TeammemberInfo::name() const {
  // @@protoc_insertion_point(field_get:NFMsg.TeammemberInfo.name)
  return name_.GetNoArena();
}
inline void TeammemberInfo::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NFMsg.TeammemberInfo.name)
}
#if LANG_CXX11
inline void TeammemberInfo::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NFMsg.TeammemberInfo.name)
}
#endif
inline void TeammemberInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NFMsg.TeammemberInfo.name)
}
inline void TeammemberInfo::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NFMsg.TeammemberInfo.name)
}
inline ::std::string* TeammemberInfo::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:NFMsg.TeammemberInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TeammemberInfo::release_name() {
  // @@protoc_insertion_point(field_release:NFMsg.TeammemberInfo.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TeammemberInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:NFMsg.TeammemberInfo.name)
}

// int32 nLevel = 3;
inline void TeammemberInfo::clear_nlevel() {
  nlevel_ = 0;
}
inline ::google::protobuf::int32 TeammemberInfo::nlevel() const {
  // @@protoc_insertion_point(field_get:NFMsg.TeammemberInfo.nLevel)
  return nlevel_;
}
inline void TeammemberInfo::set_nlevel(::google::protobuf::int32 value) {
  
  nlevel_ = value;
  // @@protoc_insertion_point(field_set:NFMsg.TeammemberInfo.nLevel)
}

// int32 job = 4;
inline void TeammemberInfo::clear_job() {
  job_ = 0;
}
inline ::google::protobuf::int32 TeammemberInfo::job() const {
  // @@protoc_insertion_point(field_get:NFMsg.TeammemberInfo.job)
  return job_;
}
inline void TeammemberInfo::set_job(::google::protobuf::int32 value) {
  
  job_ = value;
  // @@protoc_insertion_point(field_set:NFMsg.TeammemberInfo.job)
}

// string HeadIcon = 5;
inline void TeammemberInfo::clear_headicon() {
  headicon_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TeammemberInfo::headicon() const {
  // @@protoc_insertion_point(field_get:NFMsg.TeammemberInfo.HeadIcon)
  return headicon_.GetNoArena();
}
inline void TeammemberInfo::set_headicon(const ::std::string& value) {
  
  headicon_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NFMsg.TeammemberInfo.HeadIcon)
}
#if LANG_CXX11
inline void TeammemberInfo::set_headicon(::std::string&& value) {
  
  headicon_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NFMsg.TeammemberInfo.HeadIcon)
}
#endif
inline void TeammemberInfo::set_headicon(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  headicon_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NFMsg.TeammemberInfo.HeadIcon)
}
inline void TeammemberInfo::set_headicon(const char* value, size_t size) {
  
  headicon_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NFMsg.TeammemberInfo.HeadIcon)
}
inline ::std::string* TeammemberInfo::mutable_headicon() {
  
  // @@protoc_insertion_point(field_mutable:NFMsg.TeammemberInfo.HeadIcon)
  return headicon_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TeammemberInfo::release_headicon() {
  // @@protoc_insertion_point(field_release:NFMsg.TeammemberInfo.HeadIcon)
  
  return headicon_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TeammemberInfo::set_allocated_headicon(::std::string* headicon) {
  if (headicon != NULL) {
    
  } else {
    
  }
  headicon_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), headicon);
  // @@protoc_insertion_point(field_set_allocated:NFMsg.TeammemberInfo.HeadIcon)
}

// -------------------------------------------------------------------

// ReqAckCreateTeam

// .NFMsg.Ident team_id = 1;
inline bool ReqAckCreateTeam::has_team_id() const {
  return this != internal_default_instance() && team_id_ != NULL;
}
inline const ::NFMsg::Ident& ReqAckCreateTeam::_internal_team_id() const {
  return *team_id_;
}
inline const ::NFMsg::Ident& ReqAckCreateTeam::team_id() const {
  const ::NFMsg::Ident* p = team_id_;
  // @@protoc_insertion_point(field_get:NFMsg.ReqAckCreateTeam.team_id)
  return p != NULL ? *p : *reinterpret_cast<const ::NFMsg::Ident*>(
      &::NFMsg::_Ident_default_instance_);
}
inline ::NFMsg::Ident* ReqAckCreateTeam::release_team_id() {
  // @@protoc_insertion_point(field_release:NFMsg.ReqAckCreateTeam.team_id)
  
  ::NFMsg::Ident* temp = team_id_;
  team_id_ = NULL;
  return temp;
}
inline ::NFMsg::Ident* ReqAckCreateTeam::mutable_team_id() {
  
  if (team_id_ == NULL) {
    auto* p = CreateMaybeMessage<::NFMsg::Ident>(GetArenaNoVirtual());
    team_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:NFMsg.ReqAckCreateTeam.team_id)
  return team_id_;
}
inline void ReqAckCreateTeam::set_allocated_team_id(::NFMsg::Ident* team_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(team_id_);
  }
  if (team_id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      team_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, team_id, submessage_arena);
    }
    
  } else {
    
  }
  team_id_ = team_id;
  // @@protoc_insertion_point(field_set_allocated:NFMsg.ReqAckCreateTeam.team_id)
}

// .NFMsg.TeamInfo xTeamInfo = 2;
inline bool ReqAckCreateTeam::has_xteaminfo() const {
  return this != internal_default_instance() && xteaminfo_ != NULL;
}
inline void ReqAckCreateTeam::clear_xteaminfo() {
  if (GetArenaNoVirtual() == NULL && xteaminfo_ != NULL) {
    delete xteaminfo_;
  }
  xteaminfo_ = NULL;
}
inline const ::NFMsg::TeamInfo& ReqAckCreateTeam::_internal_xteaminfo() const {
  return *xteaminfo_;
}
inline const ::NFMsg::TeamInfo& ReqAckCreateTeam::xteaminfo() const {
  const ::NFMsg::TeamInfo* p = xteaminfo_;
  // @@protoc_insertion_point(field_get:NFMsg.ReqAckCreateTeam.xTeamInfo)
  return p != NULL ? *p : *reinterpret_cast<const ::NFMsg::TeamInfo*>(
      &::NFMsg::_TeamInfo_default_instance_);
}
inline ::NFMsg::TeamInfo* ReqAckCreateTeam::release_xteaminfo() {
  // @@protoc_insertion_point(field_release:NFMsg.ReqAckCreateTeam.xTeamInfo)
  
  ::NFMsg::TeamInfo* temp = xteaminfo_;
  xteaminfo_ = NULL;
  return temp;
}
inline ::NFMsg::TeamInfo* ReqAckCreateTeam::mutable_xteaminfo() {
  
  if (xteaminfo_ == NULL) {
    auto* p = CreateMaybeMessage<::NFMsg::TeamInfo>(GetArenaNoVirtual());
    xteaminfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:NFMsg.ReqAckCreateTeam.xTeamInfo)
  return xteaminfo_;
}
inline void ReqAckCreateTeam::set_allocated_xteaminfo(::NFMsg::TeamInfo* xteaminfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete xteaminfo_;
  }
  if (xteaminfo) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      xteaminfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, xteaminfo, submessage_arena);
    }
    
  } else {
    
  }
  xteaminfo_ = xteaminfo;
  // @@protoc_insertion_point(field_set_allocated:NFMsg.ReqAckCreateTeam.xTeamInfo)
}

// -------------------------------------------------------------------

// ReqAckJoinTeam

// .NFMsg.Ident team_id = 1;
inline bool ReqAckJoinTeam::has_team_id() const {
  return this != internal_default_instance() && team_id_ != NULL;
}
inline const ::NFMsg::Ident& ReqAckJoinTeam::_internal_team_id() const {
  return *team_id_;
}
inline const ::NFMsg::Ident& ReqAckJoinTeam::team_id() const {
  const ::NFMsg::Ident* p = team_id_;
  // @@protoc_insertion_point(field_get:NFMsg.ReqAckJoinTeam.team_id)
  return p != NULL ? *p : *reinterpret_cast<const ::NFMsg::Ident*>(
      &::NFMsg::_Ident_default_instance_);
}
inline ::NFMsg::Ident* ReqAckJoinTeam::release_team_id() {
  // @@protoc_insertion_point(field_release:NFMsg.ReqAckJoinTeam.team_id)
  
  ::NFMsg::Ident* temp = team_id_;
  team_id_ = NULL;
  return temp;
}
inline ::NFMsg::Ident* ReqAckJoinTeam::mutable_team_id() {
  
  if (team_id_ == NULL) {
    auto* p = CreateMaybeMessage<::NFMsg::Ident>(GetArenaNoVirtual());
    team_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:NFMsg.ReqAckJoinTeam.team_id)
  return team_id_;
}
inline void ReqAckJoinTeam::set_allocated_team_id(::NFMsg::Ident* team_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(team_id_);
  }
  if (team_id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      team_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, team_id, submessage_arena);
    }
    
  } else {
    
  }
  team_id_ = team_id;
  // @@protoc_insertion_point(field_set_allocated:NFMsg.ReqAckJoinTeam.team_id)
}

// .NFMsg.TeamInfo xTeamInfo = 2;
inline bool ReqAckJoinTeam::has_xteaminfo() const {
  return this != internal_default_instance() && xteaminfo_ != NULL;
}
inline void ReqAckJoinTeam::clear_xteaminfo() {
  if (GetArenaNoVirtual() == NULL && xteaminfo_ != NULL) {
    delete xteaminfo_;
  }
  xteaminfo_ = NULL;
}
inline const ::NFMsg::TeamInfo& ReqAckJoinTeam::_internal_xteaminfo() const {
  return *xteaminfo_;
}
inline const ::NFMsg::TeamInfo& ReqAckJoinTeam::xteaminfo() const {
  const ::NFMsg::TeamInfo* p = xteaminfo_;
  // @@protoc_insertion_point(field_get:NFMsg.ReqAckJoinTeam.xTeamInfo)
  return p != NULL ? *p : *reinterpret_cast<const ::NFMsg::TeamInfo*>(
      &::NFMsg::_TeamInfo_default_instance_);
}
inline ::NFMsg::TeamInfo* ReqAckJoinTeam::release_xteaminfo() {
  // @@protoc_insertion_point(field_release:NFMsg.ReqAckJoinTeam.xTeamInfo)
  
  ::NFMsg::TeamInfo* temp = xteaminfo_;
  xteaminfo_ = NULL;
  return temp;
}
inline ::NFMsg::TeamInfo* ReqAckJoinTeam::mutable_xteaminfo() {
  
  if (xteaminfo_ == NULL) {
    auto* p = CreateMaybeMessage<::NFMsg::TeamInfo>(GetArenaNoVirtual());
    xteaminfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:NFMsg.ReqAckJoinTeam.xTeamInfo)
  return xteaminfo_;
}
inline void ReqAckJoinTeam::set_allocated_xteaminfo(::NFMsg::TeamInfo* xteaminfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete xteaminfo_;
  }
  if (xteaminfo) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      xteaminfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, xteaminfo, submessage_arena);
    }
    
  } else {
    
  }
  xteaminfo_ = xteaminfo;
  // @@protoc_insertion_point(field_set_allocated:NFMsg.ReqAckJoinTeam.xTeamInfo)
}

// -------------------------------------------------------------------

// ReqAckLeaveTeam

// .NFMsg.Ident team_id = 1;
inline bool ReqAckLeaveTeam::has_team_id() const {
  return this != internal_default_instance() && team_id_ != NULL;
}
inline const ::NFMsg::Ident& ReqAckLeaveTeam::_internal_team_id() const {
  return *team_id_;
}
inline const ::NFMsg::Ident& ReqAckLeaveTeam::team_id() const {
  const ::NFMsg::Ident* p = team_id_;
  // @@protoc_insertion_point(field_get:NFMsg.ReqAckLeaveTeam.team_id)
  return p != NULL ? *p : *reinterpret_cast<const ::NFMsg::Ident*>(
      &::NFMsg::_Ident_default_instance_);
}
inline ::NFMsg::Ident* ReqAckLeaveTeam::release_team_id() {
  // @@protoc_insertion_point(field_release:NFMsg.ReqAckLeaveTeam.team_id)
  
  ::NFMsg::Ident* temp = team_id_;
  team_id_ = NULL;
  return temp;
}
inline ::NFMsg::Ident* ReqAckLeaveTeam::mutable_team_id() {
  
  if (team_id_ == NULL) {
    auto* p = CreateMaybeMessage<::NFMsg::Ident>(GetArenaNoVirtual());
    team_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:NFMsg.ReqAckLeaveTeam.team_id)
  return team_id_;
}
inline void ReqAckLeaveTeam::set_allocated_team_id(::NFMsg::Ident* team_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(team_id_);
  }
  if (team_id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      team_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, team_id, submessage_arena);
    }
    
  } else {
    
  }
  team_id_ = team_id;
  // @@protoc_insertion_point(field_set_allocated:NFMsg.ReqAckLeaveTeam.team_id)
}

// .NFMsg.TeamInfo xTeamInfo = 2;
inline bool ReqAckLeaveTeam::has_xteaminfo() const {
  return this != internal_default_instance() && xteaminfo_ != NULL;
}
inline void ReqAckLeaveTeam::clear_xteaminfo() {
  if (GetArenaNoVirtual() == NULL && xteaminfo_ != NULL) {
    delete xteaminfo_;
  }
  xteaminfo_ = NULL;
}
inline const ::NFMsg::TeamInfo& ReqAckLeaveTeam::_internal_xteaminfo() const {
  return *xteaminfo_;
}
inline const ::NFMsg::TeamInfo& ReqAckLeaveTeam::xteaminfo() const {
  const ::NFMsg::TeamInfo* p = xteaminfo_;
  // @@protoc_insertion_point(field_get:NFMsg.ReqAckLeaveTeam.xTeamInfo)
  return p != NULL ? *p : *reinterpret_cast<const ::NFMsg::TeamInfo*>(
      &::NFMsg::_TeamInfo_default_instance_);
}
inline ::NFMsg::TeamInfo* ReqAckLeaveTeam::release_xteaminfo() {
  // @@protoc_insertion_point(field_release:NFMsg.ReqAckLeaveTeam.xTeamInfo)
  
  ::NFMsg::TeamInfo* temp = xteaminfo_;
  xteaminfo_ = NULL;
  return temp;
}
inline ::NFMsg::TeamInfo* ReqAckLeaveTeam::mutable_xteaminfo() {
  
  if (xteaminfo_ == NULL) {
    auto* p = CreateMaybeMessage<::NFMsg::TeamInfo>(GetArenaNoVirtual());
    xteaminfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:NFMsg.ReqAckLeaveTeam.xTeamInfo)
  return xteaminfo_;
}
inline void ReqAckLeaveTeam::set_allocated_xteaminfo(::NFMsg::TeamInfo* xteaminfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete xteaminfo_;
  }
  if (xteaminfo) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      xteaminfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, xteaminfo, submessage_arena);
    }
    
  } else {
    
  }
  xteaminfo_ = xteaminfo;
  // @@protoc_insertion_point(field_set_allocated:NFMsg.ReqAckLeaveTeam.xTeamInfo)
}

// -------------------------------------------------------------------

// ReqAckOprTeamMember

// .NFMsg.Ident team_id = 1;
inline bool ReqAckOprTeamMember::has_team_id() const {
  return this != internal_default_instance() && team_id_ != NULL;
}
inline const ::NFMsg::Ident& ReqAckOprTeamMember::_internal_team_id() const {
  return *team_id_;
}
inline const ::NFMsg::Ident& ReqAckOprTeamMember::team_id() const {
  const ::NFMsg::Ident* p = team_id_;
  // @@protoc_insertion_point(field_get:NFMsg.ReqAckOprTeamMember.team_id)
  return p != NULL ? *p : *reinterpret_cast<const ::NFMsg::Ident*>(
      &::NFMsg::_Ident_default_instance_);
}
inline ::NFMsg::Ident* ReqAckOprTeamMember::release_team_id() {
  // @@protoc_insertion_point(field_release:NFMsg.ReqAckOprTeamMember.team_id)
  
  ::NFMsg::Ident* temp = team_id_;
  team_id_ = NULL;
  return temp;
}
inline ::NFMsg::Ident* ReqAckOprTeamMember::mutable_team_id() {
  
  if (team_id_ == NULL) {
    auto* p = CreateMaybeMessage<::NFMsg::Ident>(GetArenaNoVirtual());
    team_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:NFMsg.ReqAckOprTeamMember.team_id)
  return team_id_;
}
inline void ReqAckOprTeamMember::set_allocated_team_id(::NFMsg::Ident* team_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(team_id_);
  }
  if (team_id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      team_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, team_id, submessage_arena);
    }
    
  } else {
    
  }
  team_id_ = team_id;
  // @@protoc_insertion_point(field_set_allocated:NFMsg.ReqAckOprTeamMember.team_id)
}

// .NFMsg.Ident member_id = 2;
inline bool ReqAckOprTeamMember::has_member_id() const {
  return this != internal_default_instance() && member_id_ != NULL;
}
inline const ::NFMsg::Ident& ReqAckOprTeamMember::_internal_member_id() const {
  return *member_id_;
}
inline const ::NFMsg::Ident& ReqAckOprTeamMember::member_id() const {
  const ::NFMsg::Ident* p = member_id_;
  // @@protoc_insertion_point(field_get:NFMsg.ReqAckOprTeamMember.member_id)
  return p != NULL ? *p : *reinterpret_cast<const ::NFMsg::Ident*>(
      &::NFMsg::_Ident_default_instance_);
}
inline ::NFMsg::Ident* ReqAckOprTeamMember::release_member_id() {
  // @@protoc_insertion_point(field_release:NFMsg.ReqAckOprTeamMember.member_id)
  
  ::NFMsg::Ident* temp = member_id_;
  member_id_ = NULL;
  return temp;
}
inline ::NFMsg::Ident* ReqAckOprTeamMember::mutable_member_id() {
  
  if (member_id_ == NULL) {
    auto* p = CreateMaybeMessage<::NFMsg::Ident>(GetArenaNoVirtual());
    member_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:NFMsg.ReqAckOprTeamMember.member_id)
  return member_id_;
}
inline void ReqAckOprTeamMember::set_allocated_member_id(::NFMsg::Ident* member_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(member_id_);
  }
  if (member_id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      member_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, member_id, submessage_arena);
    }
    
  } else {
    
  }
  member_id_ = member_id;
  // @@protoc_insertion_point(field_set_allocated:NFMsg.ReqAckOprTeamMember.member_id)
}

// .NFMsg.ReqAckOprTeamMember.EGTeamMemberOprType type = 3;
inline void ReqAckOprTeamMember::clear_type() {
  type_ = 0;
}
inline ::NFMsg::ReqAckOprTeamMember_EGTeamMemberOprType ReqAckOprTeamMember::type() const {
  // @@protoc_insertion_point(field_get:NFMsg.ReqAckOprTeamMember.type)
  return static_cast< ::NFMsg::ReqAckOprTeamMember_EGTeamMemberOprType >(type_);
}
inline void ReqAckOprTeamMember::set_type(::NFMsg::ReqAckOprTeamMember_EGTeamMemberOprType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:NFMsg.ReqAckOprTeamMember.type)
}

// .NFMsg.TeamInfo xTeamInfo = 4;
inline bool ReqAckOprTeamMember::has_xteaminfo() const {
  return this != internal_default_instance() && xteaminfo_ != NULL;
}
inline void ReqAckOprTeamMember::clear_xteaminfo() {
  if (GetArenaNoVirtual() == NULL && xteaminfo_ != NULL) {
    delete xteaminfo_;
  }
  xteaminfo_ = NULL;
}
inline const ::NFMsg::TeamInfo& ReqAckOprTeamMember::_internal_xteaminfo() const {
  return *xteaminfo_;
}
inline const ::NFMsg::TeamInfo& ReqAckOprTeamMember::xteaminfo() const {
  const ::NFMsg::TeamInfo* p = xteaminfo_;
  // @@protoc_insertion_point(field_get:NFMsg.ReqAckOprTeamMember.xTeamInfo)
  return p != NULL ? *p : *reinterpret_cast<const ::NFMsg::TeamInfo*>(
      &::NFMsg::_TeamInfo_default_instance_);
}
inline ::NFMsg::TeamInfo* ReqAckOprTeamMember::release_xteaminfo() {
  // @@protoc_insertion_point(field_release:NFMsg.ReqAckOprTeamMember.xTeamInfo)
  
  ::NFMsg::TeamInfo* temp = xteaminfo_;
  xteaminfo_ = NULL;
  return temp;
}
inline ::NFMsg::TeamInfo* ReqAckOprTeamMember::mutable_xteaminfo() {
  
  if (xteaminfo_ == NULL) {
    auto* p = CreateMaybeMessage<::NFMsg::TeamInfo>(GetArenaNoVirtual());
    xteaminfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:NFMsg.ReqAckOprTeamMember.xTeamInfo)
  return xteaminfo_;
}
inline void ReqAckOprTeamMember::set_allocated_xteaminfo(::NFMsg::TeamInfo* xteaminfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete xteaminfo_;
  }
  if (xteaminfo) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      xteaminfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, xteaminfo, submessage_arena);
    }
    
  } else {
    
  }
  xteaminfo_ = xteaminfo;
  // @@protoc_insertion_point(field_set_allocated:NFMsg.ReqAckOprTeamMember.xTeamInfo)
}

// -------------------------------------------------------------------

// ReqAckInviteTeam

// .NFMsg.Ident team_id = 1;
inline bool ReqAckInviteTeam::has_team_id() const {
  return this != internal_default_instance() && team_id_ != NULL;
}
inline const ::NFMsg::Ident& ReqAckInviteTeam::_internal_team_id() const {
  return *team_id_;
}
inline const ::NFMsg::Ident& ReqAckInviteTeam::team_id() const {
  const ::NFMsg::Ident* p = team_id_;
  // @@protoc_insertion_point(field_get:NFMsg.ReqAckInviteTeam.team_id)
  return p != NULL ? *p : *reinterpret_cast<const ::NFMsg::Ident*>(
      &::NFMsg::_Ident_default_instance_);
}
inline ::NFMsg::Ident* ReqAckInviteTeam::release_team_id() {
  // @@protoc_insertion_point(field_release:NFMsg.ReqAckInviteTeam.team_id)
  
  ::NFMsg::Ident* temp = team_id_;
  team_id_ = NULL;
  return temp;
}
inline ::NFMsg::Ident* ReqAckInviteTeam::mutable_team_id() {
  
  if (team_id_ == NULL) {
    auto* p = CreateMaybeMessage<::NFMsg::Ident>(GetArenaNoVirtual());
    team_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:NFMsg.ReqAckInviteTeam.team_id)
  return team_id_;
}
inline void ReqAckInviteTeam::set_allocated_team_id(::NFMsg::Ident* team_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(team_id_);
  }
  if (team_id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      team_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, team_id, submessage_arena);
    }
    
  } else {
    
  }
  team_id_ = team_id;
  // @@protoc_insertion_point(field_set_allocated:NFMsg.ReqAckInviteTeam.team_id)
}

// .NFMsg.Ident self_id = 2;
inline bool ReqAckInviteTeam::has_self_id() const {
  return this != internal_default_instance() && self_id_ != NULL;
}
inline const ::NFMsg::Ident& ReqAckInviteTeam::_internal_self_id() const {
  return *self_id_;
}
inline const ::NFMsg::Ident& ReqAckInviteTeam::self_id() const {
  const ::NFMsg::Ident* p = self_id_;
  // @@protoc_insertion_point(field_get:NFMsg.ReqAckInviteTeam.self_id)
  return p != NULL ? *p : *reinterpret_cast<const ::NFMsg::Ident*>(
      &::NFMsg::_Ident_default_instance_);
}
inline ::NFMsg::Ident* ReqAckInviteTeam::release_self_id() {
  // @@protoc_insertion_point(field_release:NFMsg.ReqAckInviteTeam.self_id)
  
  ::NFMsg::Ident* temp = self_id_;
  self_id_ = NULL;
  return temp;
}
inline ::NFMsg::Ident* ReqAckInviteTeam::mutable_self_id() {
  
  if (self_id_ == NULL) {
    auto* p = CreateMaybeMessage<::NFMsg::Ident>(GetArenaNoVirtual());
    self_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:NFMsg.ReqAckInviteTeam.self_id)
  return self_id_;
}
inline void ReqAckInviteTeam::set_allocated_self_id(::NFMsg::Ident* self_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(self_id_);
  }
  if (self_id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      self_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, self_id, submessage_arena);
    }
    
  } else {
    
  }
  self_id_ = self_id;
  // @@protoc_insertion_point(field_set_allocated:NFMsg.ReqAckInviteTeam.self_id)
}

// .NFMsg.Ident invite_target_id = 3;
inline bool ReqAckInviteTeam::has_invite_target_id() const {
  return this != internal_default_instance() && invite_target_id_ != NULL;
}
inline const ::NFMsg::Ident& ReqAckInviteTeam::_internal_invite_target_id() const {
  return *invite_target_id_;
}
inline const ::NFMsg::Ident& ReqAckInviteTeam::invite_target_id() const {
  const ::NFMsg::Ident* p = invite_target_id_;
  // @@protoc_insertion_point(field_get:NFMsg.ReqAckInviteTeam.invite_target_id)
  return p != NULL ? *p : *reinterpret_cast<const ::NFMsg::Ident*>(
      &::NFMsg::_Ident_default_instance_);
}
inline ::NFMsg::Ident* ReqAckInviteTeam::release_invite_target_id() {
  // @@protoc_insertion_point(field_release:NFMsg.ReqAckInviteTeam.invite_target_id)
  
  ::NFMsg::Ident* temp = invite_target_id_;
  invite_target_id_ = NULL;
  return temp;
}
inline ::NFMsg::Ident* ReqAckInviteTeam::mutable_invite_target_id() {
  
  if (invite_target_id_ == NULL) {
    auto* p = CreateMaybeMessage<::NFMsg::Ident>(GetArenaNoVirtual());
    invite_target_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:NFMsg.ReqAckInviteTeam.invite_target_id)
  return invite_target_id_;
}
inline void ReqAckInviteTeam::set_allocated_invite_target_id(::NFMsg::Ident* invite_target_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(invite_target_id_);
  }
  if (invite_target_id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      invite_target_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, invite_target_id, submessage_arena);
    }
    
  } else {
    
  }
  invite_target_id_ = invite_target_id;
  // @@protoc_insertion_point(field_set_allocated:NFMsg.ReqAckInviteTeam.invite_target_id)
}

// -------------------------------------------------------------------

// ReqTeamEnterEctype

// .NFMsg.Ident team_id = 1;
inline bool ReqTeamEnterEctype::has_team_id() const {
  return this != internal_default_instance() && team_id_ != NULL;
}
inline const ::NFMsg::Ident& ReqTeamEnterEctype::_internal_team_id() const {
  return *team_id_;
}
inline const ::NFMsg::Ident& ReqTeamEnterEctype::team_id() const {
  const ::NFMsg::Ident* p = team_id_;
  // @@protoc_insertion_point(field_get:NFMsg.ReqTeamEnterEctype.team_id)
  return p != NULL ? *p : *reinterpret_cast<const ::NFMsg::Ident*>(
      &::NFMsg::_Ident_default_instance_);
}
inline ::NFMsg::Ident* ReqTeamEnterEctype::release_team_id() {
  // @@protoc_insertion_point(field_release:NFMsg.ReqTeamEnterEctype.team_id)
  
  ::NFMsg::Ident* temp = team_id_;
  team_id_ = NULL;
  return temp;
}
inline ::NFMsg::Ident* ReqTeamEnterEctype::mutable_team_id() {
  
  if (team_id_ == NULL) {
    auto* p = CreateMaybeMessage<::NFMsg::Ident>(GetArenaNoVirtual());
    team_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:NFMsg.ReqTeamEnterEctype.team_id)
  return team_id_;
}
inline void ReqTeamEnterEctype::set_allocated_team_id(::NFMsg::Ident* team_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(team_id_);
  }
  if (team_id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      team_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, team_id, submessage_arena);
    }
    
  } else {
    
  }
  team_id_ = team_id;
  // @@protoc_insertion_point(field_set_allocated:NFMsg.ReqTeamEnterEctype.team_id)
}

// .NFMsg.Ident self_id = 2;
inline bool ReqTeamEnterEctype::has_self_id() const {
  return this != internal_default_instance() && self_id_ != NULL;
}
inline const ::NFMsg::Ident& ReqTeamEnterEctype::_internal_self_id() const {
  return *self_id_;
}
inline const ::NFMsg::Ident& ReqTeamEnterEctype::self_id() const {
  const ::NFMsg::Ident* p = self_id_;
  // @@protoc_insertion_point(field_get:NFMsg.ReqTeamEnterEctype.self_id)
  return p != NULL ? *p : *reinterpret_cast<const ::NFMsg::Ident*>(
      &::NFMsg::_Ident_default_instance_);
}
inline ::NFMsg::Ident* ReqTeamEnterEctype::release_self_id() {
  // @@protoc_insertion_point(field_release:NFMsg.ReqTeamEnterEctype.self_id)
  
  ::NFMsg::Ident* temp = self_id_;
  self_id_ = NULL;
  return temp;
}
inline ::NFMsg::Ident* ReqTeamEnterEctype::mutable_self_id() {
  
  if (self_id_ == NULL) {
    auto* p = CreateMaybeMessage<::NFMsg::Ident>(GetArenaNoVirtual());
    self_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:NFMsg.ReqTeamEnterEctype.self_id)
  return self_id_;
}
inline void ReqTeamEnterEctype::set_allocated_self_id(::NFMsg::Ident* self_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(self_id_);
  }
  if (self_id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      self_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, self_id, submessage_arena);
    }
    
  } else {
    
  }
  self_id_ = self_id;
  // @@protoc_insertion_point(field_set_allocated:NFMsg.ReqTeamEnterEctype.self_id)
}

// int32 nEctypeID = 3;
inline void ReqTeamEnterEctype::clear_nectypeid() {
  nectypeid_ = 0;
}
inline ::google::protobuf::int32 ReqTeamEnterEctype::nectypeid() const {
  // @@protoc_insertion_point(field_get:NFMsg.ReqTeamEnterEctype.nEctypeID)
  return nectypeid_;
}
inline void ReqTeamEnterEctype::set_nectypeid(::google::protobuf::int32 value) {
  
  nectypeid_ = value;
  // @@protoc_insertion_point(field_set:NFMsg.ReqTeamEnterEctype.nEctypeID)
}

// int32 nGroupID = 4;
inline void ReqTeamEnterEctype::clear_ngroupid() {
  ngroupid_ = 0;
}
inline ::google::protobuf::int32 ReqTeamEnterEctype::ngroupid() const {
  // @@protoc_insertion_point(field_get:NFMsg.ReqTeamEnterEctype.nGroupID)
  return ngroupid_;
}
inline void ReqTeamEnterEctype::set_ngroupid(::google::protobuf::int32 value) {
  
  ngroupid_ = value;
  // @@protoc_insertion_point(field_set:NFMsg.ReqTeamEnterEctype.nGroupID)
}

// int32 nResult = 5;
inline void ReqTeamEnterEctype::clear_nresult() {
  nresult_ = 0;
}
inline ::google::protobuf::int32 ReqTeamEnterEctype::nresult() const {
  // @@protoc_insertion_point(field_get:NFMsg.ReqTeamEnterEctype.nResult)
  return nresult_;
}
inline void ReqTeamEnterEctype::set_nresult(::google::protobuf::int32 value) {
  
  nresult_ = value;
  // @@protoc_insertion_point(field_set:NFMsg.ReqTeamEnterEctype.nResult)
}

// int32 nServerID = 6;
inline void ReqTeamEnterEctype::clear_nserverid() {
  nserverid_ = 0;
}
inline ::google::protobuf::int32 ReqTeamEnterEctype::nserverid() const {
  // @@protoc_insertion_point(field_get:NFMsg.ReqTeamEnterEctype.nServerID)
  return nserverid_;
}
inline void ReqTeamEnterEctype::set_nserverid(::google::protobuf::int32 value) {
  
  nserverid_ = value;
  // @@protoc_insertion_point(field_set:NFMsg.ReqTeamEnterEctype.nServerID)
}

// -------------------------------------------------------------------

// AckTeamEnterEctype

// .NFMsg.Ident team_id = 1;
inline bool AckTeamEnterEctype::has_team_id() const {
  return this != internal_default_instance() && team_id_ != NULL;
}
inline const ::NFMsg::Ident& AckTeamEnterEctype::_internal_team_id() const {
  return *team_id_;
}
inline const ::NFMsg::Ident& AckTeamEnterEctype::team_id() const {
  const ::NFMsg::Ident* p = team_id_;
  // @@protoc_insertion_point(field_get:NFMsg.AckTeamEnterEctype.team_id)
  return p != NULL ? *p : *reinterpret_cast<const ::NFMsg::Ident*>(
      &::NFMsg::_Ident_default_instance_);
}
inline ::NFMsg::Ident* AckTeamEnterEctype::release_team_id() {
  // @@protoc_insertion_point(field_release:NFMsg.AckTeamEnterEctype.team_id)
  
  ::NFMsg::Ident* temp = team_id_;
  team_id_ = NULL;
  return temp;
}
inline ::NFMsg::Ident* AckTeamEnterEctype::mutable_team_id() {
  
  if (team_id_ == NULL) {
    auto* p = CreateMaybeMessage<::NFMsg::Ident>(GetArenaNoVirtual());
    team_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:NFMsg.AckTeamEnterEctype.team_id)
  return team_id_;
}
inline void AckTeamEnterEctype::set_allocated_team_id(::NFMsg::Ident* team_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(team_id_);
  }
  if (team_id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      team_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, team_id, submessage_arena);
    }
    
  } else {
    
  }
  team_id_ = team_id;
  // @@protoc_insertion_point(field_set_allocated:NFMsg.AckTeamEnterEctype.team_id)
}

// .NFMsg.Ident self_id = 2;
inline bool AckTeamEnterEctype::has_self_id() const {
  return this != internal_default_instance() && self_id_ != NULL;
}
inline const ::NFMsg::Ident& AckTeamEnterEctype::_internal_self_id() const {
  return *self_id_;
}
inline const ::NFMsg::Ident& AckTeamEnterEctype::self_id() const {
  const ::NFMsg::Ident* p = self_id_;
  // @@protoc_insertion_point(field_get:NFMsg.AckTeamEnterEctype.self_id)
  return p != NULL ? *p : *reinterpret_cast<const ::NFMsg::Ident*>(
      &::NFMsg::_Ident_default_instance_);
}
inline ::NFMsg::Ident* AckTeamEnterEctype::release_self_id() {
  // @@protoc_insertion_point(field_release:NFMsg.AckTeamEnterEctype.self_id)
  
  ::NFMsg::Ident* temp = self_id_;
  self_id_ = NULL;
  return temp;
}
inline ::NFMsg::Ident* AckTeamEnterEctype::mutable_self_id() {
  
  if (self_id_ == NULL) {
    auto* p = CreateMaybeMessage<::NFMsg::Ident>(GetArenaNoVirtual());
    self_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:NFMsg.AckTeamEnterEctype.self_id)
  return self_id_;
}
inline void AckTeamEnterEctype::set_allocated_self_id(::NFMsg::Ident* self_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(self_id_);
  }
  if (self_id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      self_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, self_id, submessage_arena);
    }
    
  } else {
    
  }
  self_id_ = self_id;
  // @@protoc_insertion_point(field_set_allocated:NFMsg.AckTeamEnterEctype.self_id)
}

// int32 nEctypeID = 3;
inline void AckTeamEnterEctype::clear_nectypeid() {
  nectypeid_ = 0;
}
inline ::google::protobuf::int32 AckTeamEnterEctype::nectypeid() const {
  // @@protoc_insertion_point(field_get:NFMsg.AckTeamEnterEctype.nEctypeID)
  return nectypeid_;
}
inline void AckTeamEnterEctype::set_nectypeid(::google::protobuf::int32 value) {
  
  nectypeid_ = value;
  // @@protoc_insertion_point(field_set:NFMsg.AckTeamEnterEctype.nEctypeID)
}

// int32 nGroupID = 4;
inline void AckTeamEnterEctype::clear_ngroupid() {
  ngroupid_ = 0;
}
inline ::google::protobuf::int32 AckTeamEnterEctype::ngroupid() const {
  // @@protoc_insertion_point(field_get:NFMsg.AckTeamEnterEctype.nGroupID)
  return ngroupid_;
}
inline void AckTeamEnterEctype::set_ngroupid(::google::protobuf::int32 value) {
  
  ngroupid_ = value;
  // @@protoc_insertion_point(field_set:NFMsg.AckTeamEnterEctype.nGroupID)
}

// int32 nResult = 5;
inline void AckTeamEnterEctype::clear_nresult() {
  nresult_ = 0;
}
inline ::google::protobuf::int32 AckTeamEnterEctype::nresult() const {
  // @@protoc_insertion_point(field_get:NFMsg.AckTeamEnterEctype.nResult)
  return nresult_;
}
inline void AckTeamEnterEctype::set_nresult(::google::protobuf::int32 value) {
  
  nresult_ = value;
  // @@protoc_insertion_point(field_set:NFMsg.AckTeamEnterEctype.nResult)
}

// -------------------------------------------------------------------

// GridClanBaseInfo

// .NFMsg.Ident id = 1;
inline bool GridClanBaseInfo::has_id() const {
  return this != internal_default_instance() && id_ != NULL;
}
inline const ::NFMsg::Ident& GridClanBaseInfo::_internal_id() const {
  return *id_;
}
inline const ::NFMsg::Ident& GridClanBaseInfo::id() const {
  const ::NFMsg::Ident* p = id_;
  // @@protoc_insertion_point(field_get:NFMsg.GridClanBaseInfo.id)
  return p != NULL ? *p : *reinterpret_cast<const ::NFMsg::Ident*>(
      &::NFMsg::_Ident_default_instance_);
}
inline ::NFMsg::Ident* GridClanBaseInfo::release_id() {
  // @@protoc_insertion_point(field_release:NFMsg.GridClanBaseInfo.id)
  
  ::NFMsg::Ident* temp = id_;
  id_ = NULL;
  return temp;
}
inline ::NFMsg::Ident* GridClanBaseInfo::mutable_id() {
  
  if (id_ == NULL) {
    auto* p = CreateMaybeMessage<::NFMsg::Ident>(GetArenaNoVirtual());
    id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:NFMsg.GridClanBaseInfo.id)
  return id_;
}
inline void GridClanBaseInfo::set_allocated_id(::NFMsg::Ident* id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(id_);
  }
  if (id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:NFMsg.GridClanBaseInfo.id)
}

// int32 level = 2;
inline void GridClanBaseInfo::clear_level() {
  level_ = 0;
}
inline ::google::protobuf::int32 GridClanBaseInfo::level() const {
  // @@protoc_insertion_point(field_get:NFMsg.GridClanBaseInfo.level)
  return level_;
}
inline void GridClanBaseInfo::set_level(::google::protobuf::int32 value) {
  
  level_ = value;
  // @@protoc_insertion_point(field_set:NFMsg.GridClanBaseInfo.level)
}

// int32 count = 3;
inline void GridClanBaseInfo::clear_count() {
  count_ = 0;
}
inline ::google::protobuf::int32 GridClanBaseInfo::count() const {
  // @@protoc_insertion_point(field_get:NFMsg.GridClanBaseInfo.count)
  return count_;
}
inline void GridClanBaseInfo::set_count(::google::protobuf::int32 value) {
  
  count_ = value;
  // @@protoc_insertion_point(field_set:NFMsg.GridClanBaseInfo.count)
}

// int32 resource = 4;
inline void GridClanBaseInfo::clear_resource() {
  resource_ = 0;
}
inline ::google::protobuf::int32 GridClanBaseInfo::resource() const {
  // @@protoc_insertion_point(field_get:NFMsg.GridClanBaseInfo.resource)
  return resource_;
}
inline void GridClanBaseInfo::set_resource(::google::protobuf::int32 value) {
  
  resource_ = value;
  // @@protoc_insertion_point(field_set:NFMsg.GridClanBaseInfo.resource)
}

// bytes icon = 5;
inline void GridClanBaseInfo::clear_icon() {
  icon_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GridClanBaseInfo::icon() const {
  // @@protoc_insertion_point(field_get:NFMsg.GridClanBaseInfo.icon)
  return icon_.GetNoArena();
}
inline void GridClanBaseInfo::set_icon(const ::std::string& value) {
  
  icon_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NFMsg.GridClanBaseInfo.icon)
}
#if LANG_CXX11
inline void GridClanBaseInfo::set_icon(::std::string&& value) {
  
  icon_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NFMsg.GridClanBaseInfo.icon)
}
#endif
inline void GridClanBaseInfo::set_icon(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  icon_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NFMsg.GridClanBaseInfo.icon)
}
inline void GridClanBaseInfo::set_icon(const void* value, size_t size) {
  
  icon_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NFMsg.GridClanBaseInfo.icon)
}
inline ::std::string* GridClanBaseInfo::mutable_icon() {
  
  // @@protoc_insertion_point(field_mutable:NFMsg.GridClanBaseInfo.icon)
  return icon_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GridClanBaseInfo::release_icon() {
  // @@protoc_insertion_point(field_release:NFMsg.GridClanBaseInfo.icon)
  
  return icon_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GridClanBaseInfo::set_allocated_icon(::std::string* icon) {
  if (icon != NULL) {
    
  } else {
    
  }
  icon_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), icon);
  // @@protoc_insertion_point(field_set_allocated:NFMsg.GridClanBaseInfo.icon)
}

// -------------------------------------------------------------------

// ReqBigMapGridInfo

// repeated bytes map_title_id = 1;
inline int ReqBigMapGridInfo::map_title_id_size() const {
  return map_title_id_.size();
}
inline void ReqBigMapGridInfo::clear_map_title_id() {
  map_title_id_.Clear();
}
inline const ::std::string& ReqBigMapGridInfo::map_title_id(int index) const {
  // @@protoc_insertion_point(field_get:NFMsg.ReqBigMapGridInfo.map_title_id)
  return map_title_id_.Get(index);
}
inline ::std::string* ReqBigMapGridInfo::mutable_map_title_id(int index) {
  // @@protoc_insertion_point(field_mutable:NFMsg.ReqBigMapGridInfo.map_title_id)
  return map_title_id_.Mutable(index);
}
inline void ReqBigMapGridInfo::set_map_title_id(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:NFMsg.ReqBigMapGridInfo.map_title_id)
  map_title_id_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ReqBigMapGridInfo::set_map_title_id(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:NFMsg.ReqBigMapGridInfo.map_title_id)
  map_title_id_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ReqBigMapGridInfo::set_map_title_id(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  map_title_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:NFMsg.ReqBigMapGridInfo.map_title_id)
}
inline void ReqBigMapGridInfo::set_map_title_id(int index, const void* value, size_t size) {
  map_title_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NFMsg.ReqBigMapGridInfo.map_title_id)
}
inline ::std::string* ReqBigMapGridInfo::add_map_title_id() {
  // @@protoc_insertion_point(field_add_mutable:NFMsg.ReqBigMapGridInfo.map_title_id)
  return map_title_id_.Add();
}
inline void ReqBigMapGridInfo::add_map_title_id(const ::std::string& value) {
  map_title_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:NFMsg.ReqBigMapGridInfo.map_title_id)
}
#if LANG_CXX11
inline void ReqBigMapGridInfo::add_map_title_id(::std::string&& value) {
  map_title_id_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:NFMsg.ReqBigMapGridInfo.map_title_id)
}
#endif
inline void ReqBigMapGridInfo::add_map_title_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  map_title_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:NFMsg.ReqBigMapGridInfo.map_title_id)
}
inline void ReqBigMapGridInfo::add_map_title_id(const void* value, size_t size) {
  map_title_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:NFMsg.ReqBigMapGridInfo.map_title_id)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ReqBigMapGridInfo::map_title_id() const {
  // @@protoc_insertion_point(field_list:NFMsg.ReqBigMapGridInfo.map_title_id)
  return map_title_id_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ReqBigMapGridInfo::mutable_map_title_id() {
  // @@protoc_insertion_point(field_mutable_list:NFMsg.ReqBigMapGridInfo.map_title_id)
  return &map_title_id_;
}

// -------------------------------------------------------------------

// BigMapGridBaseInfo

// bytes id = 1;
inline void BigMapGridBaseInfo::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BigMapGridBaseInfo::id() const {
  // @@protoc_insertion_point(field_get:NFMsg.BigMapGridBaseInfo.id)
  return id_.GetNoArena();
}
inline void BigMapGridBaseInfo::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NFMsg.BigMapGridBaseInfo.id)
}
#if LANG_CXX11
inline void BigMapGridBaseInfo::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NFMsg.BigMapGridBaseInfo.id)
}
#endif
inline void BigMapGridBaseInfo::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NFMsg.BigMapGridBaseInfo.id)
}
inline void BigMapGridBaseInfo::set_id(const void* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NFMsg.BigMapGridBaseInfo.id)
}
inline ::std::string* BigMapGridBaseInfo::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:NFMsg.BigMapGridBaseInfo.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BigMapGridBaseInfo::release_id() {
  // @@protoc_insertion_point(field_release:NFMsg.BigMapGridBaseInfo.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BigMapGridBaseInfo::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:NFMsg.BigMapGridBaseInfo.id)
}

// .NFMsg.GridClanBaseInfo guild_info = 2;
inline bool BigMapGridBaseInfo::has_guild_info() const {
  return this != internal_default_instance() && guild_info_ != NULL;
}
inline void BigMapGridBaseInfo::clear_guild_info() {
  if (GetArenaNoVirtual() == NULL && guild_info_ != NULL) {
    delete guild_info_;
  }
  guild_info_ = NULL;
}
inline const ::NFMsg::GridClanBaseInfo& BigMapGridBaseInfo::_internal_guild_info() const {
  return *guild_info_;
}
inline const ::NFMsg::GridClanBaseInfo& BigMapGridBaseInfo::guild_info() const {
  const ::NFMsg::GridClanBaseInfo* p = guild_info_;
  // @@protoc_insertion_point(field_get:NFMsg.BigMapGridBaseInfo.guild_info)
  return p != NULL ? *p : *reinterpret_cast<const ::NFMsg::GridClanBaseInfo*>(
      &::NFMsg::_GridClanBaseInfo_default_instance_);
}
inline ::NFMsg::GridClanBaseInfo* BigMapGridBaseInfo::release_guild_info() {
  // @@protoc_insertion_point(field_release:NFMsg.BigMapGridBaseInfo.guild_info)
  
  ::NFMsg::GridClanBaseInfo* temp = guild_info_;
  guild_info_ = NULL;
  return temp;
}
inline ::NFMsg::GridClanBaseInfo* BigMapGridBaseInfo::mutable_guild_info() {
  
  if (guild_info_ == NULL) {
    auto* p = CreateMaybeMessage<::NFMsg::GridClanBaseInfo>(GetArenaNoVirtual());
    guild_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:NFMsg.BigMapGridBaseInfo.guild_info)
  return guild_info_;
}
inline void BigMapGridBaseInfo::set_allocated_guild_info(::NFMsg::GridClanBaseInfo* guild_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete guild_info_;
  }
  if (guild_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      guild_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, guild_info, submessage_arena);
    }
    
  } else {
    
  }
  guild_info_ = guild_info;
  // @@protoc_insertion_point(field_set_allocated:NFMsg.BigMapGridBaseInfo.guild_info)
}

// int32 kingwar_time = 10;
inline void BigMapGridBaseInfo::clear_kingwar_time() {
  kingwar_time_ = 0;
}
inline ::google::protobuf::int32 BigMapGridBaseInfo::kingwar_time() const {
  // @@protoc_insertion_point(field_get:NFMsg.BigMapGridBaseInfo.kingwar_time)
  return kingwar_time_;
}
inline void BigMapGridBaseInfo::set_kingwar_time(::google::protobuf::int32 value) {
  
  kingwar_time_ = value;
  // @@protoc_insertion_point(field_set:NFMsg.BigMapGridBaseInfo.kingwar_time)
}

// .NFMsg.Ident kingwarrer = 11;
inline bool BigMapGridBaseInfo::has_kingwarrer() const {
  return this != internal_default_instance() && kingwarrer_ != NULL;
}
inline const ::NFMsg::Ident& BigMapGridBaseInfo::_internal_kingwarrer() const {
  return *kingwarrer_;
}
inline const ::NFMsg::Ident& BigMapGridBaseInfo::kingwarrer() const {
  const ::NFMsg::Ident* p = kingwarrer_;
  // @@protoc_insertion_point(field_get:NFMsg.BigMapGridBaseInfo.kingwarrer)
  return p != NULL ? *p : *reinterpret_cast<const ::NFMsg::Ident*>(
      &::NFMsg::_Ident_default_instance_);
}
inline ::NFMsg::Ident* BigMapGridBaseInfo::release_kingwarrer() {
  // @@protoc_insertion_point(field_release:NFMsg.BigMapGridBaseInfo.kingwarrer)
  
  ::NFMsg::Ident* temp = kingwarrer_;
  kingwarrer_ = NULL;
  return temp;
}
inline ::NFMsg::Ident* BigMapGridBaseInfo::mutable_kingwarrer() {
  
  if (kingwarrer_ == NULL) {
    auto* p = CreateMaybeMessage<::NFMsg::Ident>(GetArenaNoVirtual());
    kingwarrer_ = p;
  }
  // @@protoc_insertion_point(field_mutable:NFMsg.BigMapGridBaseInfo.kingwarrer)
  return kingwarrer_;
}
inline void BigMapGridBaseInfo::set_allocated_kingwarrer(::NFMsg::Ident* kingwarrer) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(kingwarrer_);
  }
  if (kingwarrer) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      kingwarrer = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, kingwarrer, submessage_arena);
    }
    
  } else {
    
  }
  kingwarrer_ = kingwarrer;
  // @@protoc_insertion_point(field_set_allocated:NFMsg.BigMapGridBaseInfo.kingwarrer)
}

// int32 hurting_time = 20;
inline void BigMapGridBaseInfo::clear_hurting_time() {
  hurting_time_ = 0;
}
inline ::google::protobuf::int32 BigMapGridBaseInfo::hurting_time() const {
  // @@protoc_insertion_point(field_get:NFMsg.BigMapGridBaseInfo.hurting_time)
  return hurting_time_;
}
inline void BigMapGridBaseInfo::set_hurting_time(::google::protobuf::int32 value) {
  
  hurting_time_ = value;
  // @@protoc_insertion_point(field_set:NFMsg.BigMapGridBaseInfo.hurting_time)
}

// .NFMsg.Ident hurter = 21;
inline bool BigMapGridBaseInfo::has_hurter() const {
  return this != internal_default_instance() && hurter_ != NULL;
}
inline const ::NFMsg::Ident& BigMapGridBaseInfo::_internal_hurter() const {
  return *hurter_;
}
inline const ::NFMsg::Ident& BigMapGridBaseInfo::hurter() const {
  const ::NFMsg::Ident* p = hurter_;
  // @@protoc_insertion_point(field_get:NFMsg.BigMapGridBaseInfo.hurter)
  return p != NULL ? *p : *reinterpret_cast<const ::NFMsg::Ident*>(
      &::NFMsg::_Ident_default_instance_);
}
inline ::NFMsg::Ident* BigMapGridBaseInfo::release_hurter() {
  // @@protoc_insertion_point(field_release:NFMsg.BigMapGridBaseInfo.hurter)
  
  ::NFMsg::Ident* temp = hurter_;
  hurter_ = NULL;
  return temp;
}
inline ::NFMsg::Ident* BigMapGridBaseInfo::mutable_hurter() {
  
  if (hurter_ == NULL) {
    auto* p = CreateMaybeMessage<::NFMsg::Ident>(GetArenaNoVirtual());
    hurter_ = p;
  }
  // @@protoc_insertion_point(field_mutable:NFMsg.BigMapGridBaseInfo.hurter)
  return hurter_;
}
inline void BigMapGridBaseInfo::set_allocated_hurter(::NFMsg::Ident* hurter) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(hurter_);
  }
  if (hurter) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      hurter = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, hurter, submessage_arena);
    }
    
  } else {
    
  }
  hurter_ = hurter;
  // @@protoc_insertion_point(field_set_allocated:NFMsg.BigMapGridBaseInfo.hurter)
}

// -------------------------------------------------------------------

// BigMapLeaveMsg

// .NFMsg.Ident owner = 1;
inline bool BigMapLeaveMsg::has_owner() const {
  return this != internal_default_instance() && owner_ != NULL;
}
inline const ::NFMsg::Ident& BigMapLeaveMsg::_internal_owner() const {
  return *owner_;
}
inline const ::NFMsg::Ident& BigMapLeaveMsg::owner() const {
  const ::NFMsg::Ident* p = owner_;
  // @@protoc_insertion_point(field_get:NFMsg.BigMapLeaveMsg.owner)
  return p != NULL ? *p : *reinterpret_cast<const ::NFMsg::Ident*>(
      &::NFMsg::_Ident_default_instance_);
}
inline ::NFMsg::Ident* BigMapLeaveMsg::release_owner() {
  // @@protoc_insertion_point(field_release:NFMsg.BigMapLeaveMsg.owner)
  
  ::NFMsg::Ident* temp = owner_;
  owner_ = NULL;
  return temp;
}
inline ::NFMsg::Ident* BigMapLeaveMsg::mutable_owner() {
  
  if (owner_ == NULL) {
    auto* p = CreateMaybeMessage<::NFMsg::Ident>(GetArenaNoVirtual());
    owner_ = p;
  }
  // @@protoc_insertion_point(field_mutable:NFMsg.BigMapLeaveMsg.owner)
  return owner_;
}
inline void BigMapLeaveMsg::set_allocated_owner(::NFMsg::Ident* owner) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(owner_);
  }
  if (owner) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      owner = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, owner, submessage_arena);
    }
    
  } else {
    
  }
  owner_ = owner;
  // @@protoc_insertion_point(field_set_allocated:NFMsg.BigMapLeaveMsg.owner)
}

// bytes owner_name = 2;
inline void BigMapLeaveMsg::clear_owner_name() {
  owner_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BigMapLeaveMsg::owner_name() const {
  // @@protoc_insertion_point(field_get:NFMsg.BigMapLeaveMsg.owner_name)
  return owner_name_.GetNoArena();
}
inline void BigMapLeaveMsg::set_owner_name(const ::std::string& value) {
  
  owner_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NFMsg.BigMapLeaveMsg.owner_name)
}
#if LANG_CXX11
inline void BigMapLeaveMsg::set_owner_name(::std::string&& value) {
  
  owner_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NFMsg.BigMapLeaveMsg.owner_name)
}
#endif
inline void BigMapLeaveMsg::set_owner_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  owner_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NFMsg.BigMapLeaveMsg.owner_name)
}
inline void BigMapLeaveMsg::set_owner_name(const void* value, size_t size) {
  
  owner_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NFMsg.BigMapLeaveMsg.owner_name)
}
inline ::std::string* BigMapLeaveMsg::mutable_owner_name() {
  
  // @@protoc_insertion_point(field_mutable:NFMsg.BigMapLeaveMsg.owner_name)
  return owner_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BigMapLeaveMsg::release_owner_name() {
  // @@protoc_insertion_point(field_release:NFMsg.BigMapLeaveMsg.owner_name)
  
  return owner_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BigMapLeaveMsg::set_allocated_owner_name(::std::string* owner_name) {
  if (owner_name != NULL) {
    
  } else {
    
  }
  owner_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), owner_name);
  // @@protoc_insertion_point(field_set_allocated:NFMsg.BigMapLeaveMsg.owner_name)
}

// bytes msg_data = 3;
inline void BigMapLeaveMsg::clear_msg_data() {
  msg_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BigMapLeaveMsg::msg_data() const {
  // @@protoc_insertion_point(field_get:NFMsg.BigMapLeaveMsg.msg_data)
  return msg_data_.GetNoArena();
}
inline void BigMapLeaveMsg::set_msg_data(const ::std::string& value) {
  
  msg_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NFMsg.BigMapLeaveMsg.msg_data)
}
#if LANG_CXX11
inline void BigMapLeaveMsg::set_msg_data(::std::string&& value) {
  
  msg_data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NFMsg.BigMapLeaveMsg.msg_data)
}
#endif
inline void BigMapLeaveMsg::set_msg_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  msg_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NFMsg.BigMapLeaveMsg.msg_data)
}
inline void BigMapLeaveMsg::set_msg_data(const void* value, size_t size) {
  
  msg_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NFMsg.BigMapLeaveMsg.msg_data)
}
inline ::std::string* BigMapLeaveMsg::mutable_msg_data() {
  
  // @@protoc_insertion_point(field_mutable:NFMsg.BigMapLeaveMsg.msg_data)
  return msg_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BigMapLeaveMsg::release_msg_data() {
  // @@protoc_insertion_point(field_release:NFMsg.BigMapLeaveMsg.msg_data)
  
  return msg_data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BigMapLeaveMsg::set_allocated_msg_data(::std::string* msg_data) {
  if (msg_data != NULL) {
    
  } else {
    
  }
  msg_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), msg_data);
  // @@protoc_insertion_point(field_set_allocated:NFMsg.BigMapLeaveMsg.msg_data)
}

// int32 msg_time = 4;
inline void BigMapLeaveMsg::clear_msg_time() {
  msg_time_ = 0;
}
inline ::google::protobuf::int32 BigMapLeaveMsg::msg_time() const {
  // @@protoc_insertion_point(field_get:NFMsg.BigMapLeaveMsg.msg_time)
  return msg_time_;
}
inline void BigMapLeaveMsg::set_msg_time(::google::protobuf::int32 value) {
  
  msg_time_ = value;
  // @@protoc_insertion_point(field_set:NFMsg.BigMapLeaveMsg.msg_time)
}

// int32 owner_level = 5;
inline void BigMapLeaveMsg::clear_owner_level() {
  owner_level_ = 0;
}
inline ::google::protobuf::int32 BigMapLeaveMsg::owner_level() const {
  // @@protoc_insertion_point(field_get:NFMsg.BigMapLeaveMsg.owner_level)
  return owner_level_;
}
inline void BigMapLeaveMsg::set_owner_level(::google::protobuf::int32 value) {
  
  owner_level_ = value;
  // @@protoc_insertion_point(field_set:NFMsg.BigMapLeaveMsg.owner_level)
}

// -------------------------------------------------------------------

// BigMapWarHistory

// .NFMsg.GridClanBaseInfo red_info = 1;
inline bool BigMapWarHistory::has_red_info() const {
  return this != internal_default_instance() && red_info_ != NULL;
}
inline void BigMapWarHistory::clear_red_info() {
  if (GetArenaNoVirtual() == NULL && red_info_ != NULL) {
    delete red_info_;
  }
  red_info_ = NULL;
}
inline const ::NFMsg::GridClanBaseInfo& BigMapWarHistory::_internal_red_info() const {
  return *red_info_;
}
inline const ::NFMsg::GridClanBaseInfo& BigMapWarHistory::red_info() const {
  const ::NFMsg::GridClanBaseInfo* p = red_info_;
  // @@protoc_insertion_point(field_get:NFMsg.BigMapWarHistory.red_info)
  return p != NULL ? *p : *reinterpret_cast<const ::NFMsg::GridClanBaseInfo*>(
      &::NFMsg::_GridClanBaseInfo_default_instance_);
}
inline ::NFMsg::GridClanBaseInfo* BigMapWarHistory::release_red_info() {
  // @@protoc_insertion_point(field_release:NFMsg.BigMapWarHistory.red_info)
  
  ::NFMsg::GridClanBaseInfo* temp = red_info_;
  red_info_ = NULL;
  return temp;
}
inline ::NFMsg::GridClanBaseInfo* BigMapWarHistory::mutable_red_info() {
  
  if (red_info_ == NULL) {
    auto* p = CreateMaybeMessage<::NFMsg::GridClanBaseInfo>(GetArenaNoVirtual());
    red_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:NFMsg.BigMapWarHistory.red_info)
  return red_info_;
}
inline void BigMapWarHistory::set_allocated_red_info(::NFMsg::GridClanBaseInfo* red_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete red_info_;
  }
  if (red_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      red_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, red_info, submessage_arena);
    }
    
  } else {
    
  }
  red_info_ = red_info;
  // @@protoc_insertion_point(field_set_allocated:NFMsg.BigMapWarHistory.red_info)
}

// .NFMsg.GridClanBaseInfo blue_info = 2;
inline bool BigMapWarHistory::has_blue_info() const {
  return this != internal_default_instance() && blue_info_ != NULL;
}
inline void BigMapWarHistory::clear_blue_info() {
  if (GetArenaNoVirtual() == NULL && blue_info_ != NULL) {
    delete blue_info_;
  }
  blue_info_ = NULL;
}
inline const ::NFMsg::GridClanBaseInfo& BigMapWarHistory::_internal_blue_info() const {
  return *blue_info_;
}
inline const ::NFMsg::GridClanBaseInfo& BigMapWarHistory::blue_info() const {
  const ::NFMsg::GridClanBaseInfo* p = blue_info_;
  // @@protoc_insertion_point(field_get:NFMsg.BigMapWarHistory.blue_info)
  return p != NULL ? *p : *reinterpret_cast<const ::NFMsg::GridClanBaseInfo*>(
      &::NFMsg::_GridClanBaseInfo_default_instance_);
}
inline ::NFMsg::GridClanBaseInfo* BigMapWarHistory::release_blue_info() {
  // @@protoc_insertion_point(field_release:NFMsg.BigMapWarHistory.blue_info)
  
  ::NFMsg::GridClanBaseInfo* temp = blue_info_;
  blue_info_ = NULL;
  return temp;
}
inline ::NFMsg::GridClanBaseInfo* BigMapWarHistory::mutable_blue_info() {
  
  if (blue_info_ == NULL) {
    auto* p = CreateMaybeMessage<::NFMsg::GridClanBaseInfo>(GetArenaNoVirtual());
    blue_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:NFMsg.BigMapWarHistory.blue_info)
  return blue_info_;
}
inline void BigMapWarHistory::set_allocated_blue_info(::NFMsg::GridClanBaseInfo* blue_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete blue_info_;
  }
  if (blue_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      blue_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, blue_info, submessage_arena);
    }
    
  } else {
    
  }
  blue_info_ = blue_info;
  // @@protoc_insertion_point(field_set_allocated:NFMsg.BigMapWarHistory.blue_info)
}

// .NFMsg.Ident winner_id = 10;
inline bool BigMapWarHistory::has_winner_id() const {
  return this != internal_default_instance() && winner_id_ != NULL;
}
inline const ::NFMsg::Ident& BigMapWarHistory::_internal_winner_id() const {
  return *winner_id_;
}
inline const ::NFMsg::Ident& BigMapWarHistory::winner_id() const {
  const ::NFMsg::Ident* p = winner_id_;
  // @@protoc_insertion_point(field_get:NFMsg.BigMapWarHistory.winner_id)
  return p != NULL ? *p : *reinterpret_cast<const ::NFMsg::Ident*>(
      &::NFMsg::_Ident_default_instance_);
}
inline ::NFMsg::Ident* BigMapWarHistory::release_winner_id() {
  // @@protoc_insertion_point(field_release:NFMsg.BigMapWarHistory.winner_id)
  
  ::NFMsg::Ident* temp = winner_id_;
  winner_id_ = NULL;
  return temp;
}
inline ::NFMsg::Ident* BigMapWarHistory::mutable_winner_id() {
  
  if (winner_id_ == NULL) {
    auto* p = CreateMaybeMessage<::NFMsg::Ident>(GetArenaNoVirtual());
    winner_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:NFMsg.BigMapWarHistory.winner_id)
  return winner_id_;
}
inline void BigMapWarHistory::set_allocated_winner_id(::NFMsg::Ident* winner_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(winner_id_);
  }
  if (winner_id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      winner_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, winner_id, submessage_arena);
    }
    
  } else {
    
  }
  winner_id_ = winner_id;
  // @@protoc_insertion_point(field_set_allocated:NFMsg.BigMapWarHistory.winner_id)
}

// int32 war_time = 11;
inline void BigMapWarHistory::clear_war_time() {
  war_time_ = 0;
}
inline ::google::protobuf::int32 BigMapWarHistory::war_time() const {
  // @@protoc_insertion_point(field_get:NFMsg.BigMapWarHistory.war_time)
  return war_time_;
}
inline void BigMapWarHistory::set_war_time(::google::protobuf::int32 value) {
  
  war_time_ = value;
  // @@protoc_insertion_point(field_set:NFMsg.BigMapWarHistory.war_time)
}

// -------------------------------------------------------------------

// BigMapGridDetailInfo

// .NFMsg.BigMapGridBaseInfo grid_base_info = 1;
inline bool BigMapGridDetailInfo::has_grid_base_info() const {
  return this != internal_default_instance() && grid_base_info_ != NULL;
}
inline void BigMapGridDetailInfo::clear_grid_base_info() {
  if (GetArenaNoVirtual() == NULL && grid_base_info_ != NULL) {
    delete grid_base_info_;
  }
  grid_base_info_ = NULL;
}
inline const ::NFMsg::BigMapGridBaseInfo& BigMapGridDetailInfo::_internal_grid_base_info() const {
  return *grid_base_info_;
}
inline const ::NFMsg::BigMapGridBaseInfo& BigMapGridDetailInfo::grid_base_info() const {
  const ::NFMsg::BigMapGridBaseInfo* p = grid_base_info_;
  // @@protoc_insertion_point(field_get:NFMsg.BigMapGridDetailInfo.grid_base_info)
  return p != NULL ? *p : *reinterpret_cast<const ::NFMsg::BigMapGridBaseInfo*>(
      &::NFMsg::_BigMapGridBaseInfo_default_instance_);
}
inline ::NFMsg::BigMapGridBaseInfo* BigMapGridDetailInfo::release_grid_base_info() {
  // @@protoc_insertion_point(field_release:NFMsg.BigMapGridDetailInfo.grid_base_info)
  
  ::NFMsg::BigMapGridBaseInfo* temp = grid_base_info_;
  grid_base_info_ = NULL;
  return temp;
}
inline ::NFMsg::BigMapGridBaseInfo* BigMapGridDetailInfo::mutable_grid_base_info() {
  
  if (grid_base_info_ == NULL) {
    auto* p = CreateMaybeMessage<::NFMsg::BigMapGridBaseInfo>(GetArenaNoVirtual());
    grid_base_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:NFMsg.BigMapGridDetailInfo.grid_base_info)
  return grid_base_info_;
}
inline void BigMapGridDetailInfo::set_allocated_grid_base_info(::NFMsg::BigMapGridBaseInfo* grid_base_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete grid_base_info_;
  }
  if (grid_base_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      grid_base_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, grid_base_info, submessage_arena);
    }
    
  } else {
    
  }
  grid_base_info_ = grid_base_info;
  // @@protoc_insertion_point(field_set_allocated:NFMsg.BigMapGridDetailInfo.grid_base_info)
}

// repeated .NFMsg.GridClanBaseInfo stay_guid_list = 2;
inline int BigMapGridDetailInfo::stay_guid_list_size() const {
  return stay_guid_list_.size();
}
inline void BigMapGridDetailInfo::clear_stay_guid_list() {
  stay_guid_list_.Clear();
}
inline ::NFMsg::GridClanBaseInfo* BigMapGridDetailInfo::mutable_stay_guid_list(int index) {
  // @@protoc_insertion_point(field_mutable:NFMsg.BigMapGridDetailInfo.stay_guid_list)
  return stay_guid_list_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NFMsg::GridClanBaseInfo >*
BigMapGridDetailInfo::mutable_stay_guid_list() {
  // @@protoc_insertion_point(field_mutable_list:NFMsg.BigMapGridDetailInfo.stay_guid_list)
  return &stay_guid_list_;
}
inline const ::NFMsg::GridClanBaseInfo& BigMapGridDetailInfo::stay_guid_list(int index) const {
  // @@protoc_insertion_point(field_get:NFMsg.BigMapGridDetailInfo.stay_guid_list)
  return stay_guid_list_.Get(index);
}
inline ::NFMsg::GridClanBaseInfo* BigMapGridDetailInfo::add_stay_guid_list() {
  // @@protoc_insertion_point(field_add:NFMsg.BigMapGridDetailInfo.stay_guid_list)
  return stay_guid_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NFMsg::GridClanBaseInfo >&
BigMapGridDetailInfo::stay_guid_list() const {
  // @@protoc_insertion_point(field_list:NFMsg.BigMapGridDetailInfo.stay_guid_list)
  return stay_guid_list_;
}

// repeated .NFMsg.BigMapLeaveMsg leave_msg = 3;
inline int BigMapGridDetailInfo::leave_msg_size() const {
  return leave_msg_.size();
}
inline void BigMapGridDetailInfo::clear_leave_msg() {
  leave_msg_.Clear();
}
inline ::NFMsg::BigMapLeaveMsg* BigMapGridDetailInfo::mutable_leave_msg(int index) {
  // @@protoc_insertion_point(field_mutable:NFMsg.BigMapGridDetailInfo.leave_msg)
  return leave_msg_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NFMsg::BigMapLeaveMsg >*
BigMapGridDetailInfo::mutable_leave_msg() {
  // @@protoc_insertion_point(field_mutable_list:NFMsg.BigMapGridDetailInfo.leave_msg)
  return &leave_msg_;
}
inline const ::NFMsg::BigMapLeaveMsg& BigMapGridDetailInfo::leave_msg(int index) const {
  // @@protoc_insertion_point(field_get:NFMsg.BigMapGridDetailInfo.leave_msg)
  return leave_msg_.Get(index);
}
inline ::NFMsg::BigMapLeaveMsg* BigMapGridDetailInfo::add_leave_msg() {
  // @@protoc_insertion_point(field_add:NFMsg.BigMapGridDetailInfo.leave_msg)
  return leave_msg_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NFMsg::BigMapLeaveMsg >&
BigMapGridDetailInfo::leave_msg() const {
  // @@protoc_insertion_point(field_list:NFMsg.BigMapGridDetailInfo.leave_msg)
  return leave_msg_;
}

// repeated .NFMsg.BigMapWarHistory war_history = 4;
inline int BigMapGridDetailInfo::war_history_size() const {
  return war_history_.size();
}
inline void BigMapGridDetailInfo::clear_war_history() {
  war_history_.Clear();
}
inline ::NFMsg::BigMapWarHistory* BigMapGridDetailInfo::mutable_war_history(int index) {
  // @@protoc_insertion_point(field_mutable:NFMsg.BigMapGridDetailInfo.war_history)
  return war_history_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NFMsg::BigMapWarHistory >*
BigMapGridDetailInfo::mutable_war_history() {
  // @@protoc_insertion_point(field_mutable_list:NFMsg.BigMapGridDetailInfo.war_history)
  return &war_history_;
}
inline const ::NFMsg::BigMapWarHistory& BigMapGridDetailInfo::war_history(int index) const {
  // @@protoc_insertion_point(field_get:NFMsg.BigMapGridDetailInfo.war_history)
  return war_history_.Get(index);
}
inline ::NFMsg::BigMapWarHistory* BigMapGridDetailInfo::add_war_history() {
  // @@protoc_insertion_point(field_add:NFMsg.BigMapGridDetailInfo.war_history)
  return war_history_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NFMsg::BigMapWarHistory >&
BigMapGridDetailInfo::war_history() const {
  // @@protoc_insertion_point(field_list:NFMsg.BigMapGridDetailInfo.war_history)
  return war_history_;
}

// -------------------------------------------------------------------

// AckBigMapGridInfo

// repeated .NFMsg.BigMapGridDetailInfo map_data = 1;
inline int AckBigMapGridInfo::map_data_size() const {
  return map_data_.size();
}
inline void AckBigMapGridInfo::clear_map_data() {
  map_data_.Clear();
}
inline ::NFMsg::BigMapGridDetailInfo* AckBigMapGridInfo::mutable_map_data(int index) {
  // @@protoc_insertion_point(field_mutable:NFMsg.AckBigMapGridInfo.map_data)
  return map_data_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NFMsg::BigMapGridDetailInfo >*
AckBigMapGridInfo::mutable_map_data() {
  // @@protoc_insertion_point(field_mutable_list:NFMsg.AckBigMapGridInfo.map_data)
  return &map_data_;
}
inline const ::NFMsg::BigMapGridDetailInfo& AckBigMapGridInfo::map_data(int index) const {
  // @@protoc_insertion_point(field_get:NFMsg.AckBigMapGridInfo.map_data)
  return map_data_.Get(index);
}
inline ::NFMsg::BigMapGridDetailInfo* AckBigMapGridInfo::add_map_data() {
  // @@protoc_insertion_point(field_add:NFMsg.AckBigMapGridInfo.map_data)
  return map_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NFMsg::BigMapGridDetailInfo >&
AckBigMapGridInfo::map_data() const {
  // @@protoc_insertion_point(field_list:NFMsg.AckBigMapGridInfo.map_data)
  return map_data_;
}

// -------------------------------------------------------------------

// ReqBigMapInfo

// -------------------------------------------------------------------

// AckBigMapInfo

// repeated .NFMsg.BigMapGridBaseInfo grid_base_info = 1;
inline int AckBigMapInfo::grid_base_info_size() const {
  return grid_base_info_.size();
}
inline void AckBigMapInfo::clear_grid_base_info() {
  grid_base_info_.Clear();
}
inline ::NFMsg::BigMapGridBaseInfo* AckBigMapInfo::mutable_grid_base_info(int index) {
  // @@protoc_insertion_point(field_mutable:NFMsg.AckBigMapInfo.grid_base_info)
  return grid_base_info_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::NFMsg::BigMapGridBaseInfo >*
AckBigMapInfo::mutable_grid_base_info() {
  // @@protoc_insertion_point(field_mutable_list:NFMsg.AckBigMapInfo.grid_base_info)
  return &grid_base_info_;
}
inline const ::NFMsg::BigMapGridBaseInfo& AckBigMapInfo::grid_base_info(int index) const {
  // @@protoc_insertion_point(field_get:NFMsg.AckBigMapInfo.grid_base_info)
  return grid_base_info_.Get(index);
}
inline ::NFMsg::BigMapGridBaseInfo* AckBigMapInfo::add_grid_base_info() {
  // @@protoc_insertion_point(field_add:NFMsg.AckBigMapInfo.grid_base_info)
  return grid_base_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NFMsg::BigMapGridBaseInfo >&
AckBigMapInfo::grid_base_info() const {
  // @@protoc_insertion_point(field_list:NFMsg.AckBigMapInfo.grid_base_info)
  return grid_base_info_;
}

// -------------------------------------------------------------------

// ReqHoldMapGrid

// bytes map_title_id = 1;
inline void ReqHoldMapGrid::clear_map_title_id() {
  map_title_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ReqHoldMapGrid::map_title_id() const {
  // @@protoc_insertion_point(field_get:NFMsg.ReqHoldMapGrid.map_title_id)
  return map_title_id_.GetNoArena();
}
inline void ReqHoldMapGrid::set_map_title_id(const ::std::string& value) {
  
  map_title_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NFMsg.ReqHoldMapGrid.map_title_id)
}
#if LANG_CXX11
inline void ReqHoldMapGrid::set_map_title_id(::std::string&& value) {
  
  map_title_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NFMsg.ReqHoldMapGrid.map_title_id)
}
#endif
inline void ReqHoldMapGrid::set_map_title_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  map_title_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NFMsg.ReqHoldMapGrid.map_title_id)
}
inline void ReqHoldMapGrid::set_map_title_id(const void* value, size_t size) {
  
  map_title_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NFMsg.ReqHoldMapGrid.map_title_id)
}
inline ::std::string* ReqHoldMapGrid::mutable_map_title_id() {
  
  // @@protoc_insertion_point(field_mutable:NFMsg.ReqHoldMapGrid.map_title_id)
  return map_title_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReqHoldMapGrid::release_map_title_id() {
  // @@protoc_insertion_point(field_release:NFMsg.ReqHoldMapGrid.map_title_id)
  
  return map_title_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReqHoldMapGrid::set_allocated_map_title_id(::std::string* map_title_id) {
  if (map_title_id != NULL) {
    
  } else {
    
  }
  map_title_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), map_title_id);
  // @@protoc_insertion_point(field_set_allocated:NFMsg.ReqHoldMapGrid.map_title_id)
}

// .NFMsg.Ident guild_id = 2;
inline bool ReqHoldMapGrid::has_guild_id() const {
  return this != internal_default_instance() && guild_id_ != NULL;
}
inline const ::NFMsg::Ident& ReqHoldMapGrid::_internal_guild_id() const {
  return *guild_id_;
}
inline const ::NFMsg::Ident& ReqHoldMapGrid::guild_id() const {
  const ::NFMsg::Ident* p = guild_id_;
  // @@protoc_insertion_point(field_get:NFMsg.ReqHoldMapGrid.guild_id)
  return p != NULL ? *p : *reinterpret_cast<const ::NFMsg::Ident*>(
      &::NFMsg::_Ident_default_instance_);
}
inline ::NFMsg::Ident* ReqHoldMapGrid::release_guild_id() {
  // @@protoc_insertion_point(field_release:NFMsg.ReqHoldMapGrid.guild_id)
  
  ::NFMsg::Ident* temp = guild_id_;
  guild_id_ = NULL;
  return temp;
}
inline ::NFMsg::Ident* ReqHoldMapGrid::mutable_guild_id() {
  
  if (guild_id_ == NULL) {
    auto* p = CreateMaybeMessage<::NFMsg::Ident>(GetArenaNoVirtual());
    guild_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:NFMsg.ReqHoldMapGrid.guild_id)
  return guild_id_;
}
inline void ReqHoldMapGrid::set_allocated_guild_id(::NFMsg::Ident* guild_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(guild_id_);
  }
  if (guild_id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      guild_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, guild_id, submessage_arena);
    }
    
  } else {
    
  }
  guild_id_ = guild_id;
  // @@protoc_insertion_point(field_set_allocated:NFMsg.ReqHoldMapGrid.guild_id)
}

// -------------------------------------------------------------------

// AckHoldMapGrid

// -------------------------------------------------------------------

// ReqLeaveMapMsg

// bytes map_title_id = 1;
inline void ReqLeaveMapMsg::clear_map_title_id() {
  map_title_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ReqLeaveMapMsg::map_title_id() const {
  // @@protoc_insertion_point(field_get:NFMsg.ReqLeaveMapMsg.map_title_id)
  return map_title_id_.GetNoArena();
}
inline void ReqLeaveMapMsg::set_map_title_id(const ::std::string& value) {
  
  map_title_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NFMsg.ReqLeaveMapMsg.map_title_id)
}
#if LANG_CXX11
inline void ReqLeaveMapMsg::set_map_title_id(::std::string&& value) {
  
  map_title_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NFMsg.ReqLeaveMapMsg.map_title_id)
}
#endif
inline void ReqLeaveMapMsg::set_map_title_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  map_title_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NFMsg.ReqLeaveMapMsg.map_title_id)
}
inline void ReqLeaveMapMsg::set_map_title_id(const void* value, size_t size) {
  
  map_title_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NFMsg.ReqLeaveMapMsg.map_title_id)
}
inline ::std::string* ReqLeaveMapMsg::mutable_map_title_id() {
  
  // @@protoc_insertion_point(field_mutable:NFMsg.ReqLeaveMapMsg.map_title_id)
  return map_title_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReqLeaveMapMsg::release_map_title_id() {
  // @@protoc_insertion_point(field_release:NFMsg.ReqLeaveMapMsg.map_title_id)
  
  return map_title_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReqLeaveMapMsg::set_allocated_map_title_id(::std::string* map_title_id) {
  if (map_title_id != NULL) {
    
  } else {
    
  }
  map_title_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), map_title_id);
  // @@protoc_insertion_point(field_set_allocated:NFMsg.ReqLeaveMapMsg.map_title_id)
}

// .NFMsg.BigMapLeaveMsg leave_msg = 2;
inline bool ReqLeaveMapMsg::has_leave_msg() const {
  return this != internal_default_instance() && leave_msg_ != NULL;
}
inline void ReqLeaveMapMsg::clear_leave_msg() {
  if (GetArenaNoVirtual() == NULL && leave_msg_ != NULL) {
    delete leave_msg_;
  }
  leave_msg_ = NULL;
}
inline const ::NFMsg::BigMapLeaveMsg& ReqLeaveMapMsg::_internal_leave_msg() const {
  return *leave_msg_;
}
inline const ::NFMsg::BigMapLeaveMsg& ReqLeaveMapMsg::leave_msg() const {
  const ::NFMsg::BigMapLeaveMsg* p = leave_msg_;
  // @@protoc_insertion_point(field_get:NFMsg.ReqLeaveMapMsg.leave_msg)
  return p != NULL ? *p : *reinterpret_cast<const ::NFMsg::BigMapLeaveMsg*>(
      &::NFMsg::_BigMapLeaveMsg_default_instance_);
}
inline ::NFMsg::BigMapLeaveMsg* ReqLeaveMapMsg::release_leave_msg() {
  // @@protoc_insertion_point(field_release:NFMsg.ReqLeaveMapMsg.leave_msg)
  
  ::NFMsg::BigMapLeaveMsg* temp = leave_msg_;
  leave_msg_ = NULL;
  return temp;
}
inline ::NFMsg::BigMapLeaveMsg* ReqLeaveMapMsg::mutable_leave_msg() {
  
  if (leave_msg_ == NULL) {
    auto* p = CreateMaybeMessage<::NFMsg::BigMapLeaveMsg>(GetArenaNoVirtual());
    leave_msg_ = p;
  }
  // @@protoc_insertion_point(field_mutable:NFMsg.ReqLeaveMapMsg.leave_msg)
  return leave_msg_;
}
inline void ReqLeaveMapMsg::set_allocated_leave_msg(::NFMsg::BigMapLeaveMsg* leave_msg) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete leave_msg_;
  }
  if (leave_msg) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      leave_msg = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, leave_msg, submessage_arena);
    }
    
  } else {
    
  }
  leave_msg_ = leave_msg;
  // @@protoc_insertion_point(field_set_allocated:NFMsg.ReqLeaveMapMsg.leave_msg)
}

// -------------------------------------------------------------------

// AckLeaveMapMsg

// -------------------------------------------------------------------

// ReqGetMapAward

// bytes map_title_id = 1;
inline void ReqGetMapAward::clear_map_title_id() {
  map_title_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ReqGetMapAward::map_title_id() const {
  // @@protoc_insertion_point(field_get:NFMsg.ReqGetMapAward.map_title_id)
  return map_title_id_.GetNoArena();
}
inline void ReqGetMapAward::set_map_title_id(const ::std::string& value) {
  
  map_title_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NFMsg.ReqGetMapAward.map_title_id)
}
#if LANG_CXX11
inline void ReqGetMapAward::set_map_title_id(::std::string&& value) {
  
  map_title_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NFMsg.ReqGetMapAward.map_title_id)
}
#endif
inline void ReqGetMapAward::set_map_title_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  map_title_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NFMsg.ReqGetMapAward.map_title_id)
}
inline void ReqGetMapAward::set_map_title_id(const void* value, size_t size) {
  
  map_title_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NFMsg.ReqGetMapAward.map_title_id)
}
inline ::std::string* ReqGetMapAward::mutable_map_title_id() {
  
  // @@protoc_insertion_point(field_mutable:NFMsg.ReqGetMapAward.map_title_id)
  return map_title_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReqGetMapAward::release_map_title_id() {
  // @@protoc_insertion_point(field_release:NFMsg.ReqGetMapAward.map_title_id)
  
  return map_title_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReqGetMapAward::set_allocated_map_title_id(::std::string* map_title_id) {
  if (map_title_id != NULL) {
    
  } else {
    
  }
  map_title_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), map_title_id);
  // @@protoc_insertion_point(field_set_allocated:NFMsg.ReqGetMapAward.map_title_id)
}

// -------------------------------------------------------------------

// AckGetMapAward

// -------------------------------------------------------------------

// ReqMapHunting

// bytes map_title_id = 1;
inline void ReqMapHunting::clear_map_title_id() {
  map_title_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ReqMapHunting::map_title_id() const {
  // @@protoc_insertion_point(field_get:NFMsg.ReqMapHunting.map_title_id)
  return map_title_id_.GetNoArena();
}
inline void ReqMapHunting::set_map_title_id(const ::std::string& value) {
  
  map_title_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NFMsg.ReqMapHunting.map_title_id)
}
#if LANG_CXX11
inline void ReqMapHunting::set_map_title_id(::std::string&& value) {
  
  map_title_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NFMsg.ReqMapHunting.map_title_id)
}
#endif
inline void ReqMapHunting::set_map_title_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  map_title_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NFMsg.ReqMapHunting.map_title_id)
}
inline void ReqMapHunting::set_map_title_id(const void* value, size_t size) {
  
  map_title_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NFMsg.ReqMapHunting.map_title_id)
}
inline ::std::string* ReqMapHunting::mutable_map_title_id() {
  
  // @@protoc_insertion_point(field_mutable:NFMsg.ReqMapHunting.map_title_id)
  return map_title_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReqMapHunting::release_map_title_id() {
  // @@protoc_insertion_point(field_release:NFMsg.ReqMapHunting.map_title_id)
  
  return map_title_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReqMapHunting::set_allocated_map_title_id(::std::string* map_title_id) {
  if (map_title_id != NULL) {
    
  } else {
    
  }
  map_title_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), map_title_id);
  // @@protoc_insertion_point(field_set_allocated:NFMsg.ReqMapHunting.map_title_id)
}

// -------------------------------------------------------------------

// AckMapHunting

// -------------------------------------------------------------------

// ReqMapKingWar

// bytes map_title = 1;
inline void ReqMapKingWar::clear_map_title() {
  map_title_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ReqMapKingWar::map_title() const {
  // @@protoc_insertion_point(field_get:NFMsg.ReqMapKingWar.map_title)
  return map_title_.GetNoArena();
}
inline void ReqMapKingWar::set_map_title(const ::std::string& value) {
  
  map_title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NFMsg.ReqMapKingWar.map_title)
}
#if LANG_CXX11
inline void ReqMapKingWar::set_map_title(::std::string&& value) {
  
  map_title_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NFMsg.ReqMapKingWar.map_title)
}
#endif
inline void ReqMapKingWar::set_map_title(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  map_title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NFMsg.ReqMapKingWar.map_title)
}
inline void ReqMapKingWar::set_map_title(const void* value, size_t size) {
  
  map_title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NFMsg.ReqMapKingWar.map_title)
}
inline ::std::string* ReqMapKingWar::mutable_map_title() {
  
  // @@protoc_insertion_point(field_mutable:NFMsg.ReqMapKingWar.map_title)
  return map_title_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReqMapKingWar::release_map_title() {
  // @@protoc_insertion_point(field_release:NFMsg.ReqMapKingWar.map_title)
  
  return map_title_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReqMapKingWar::set_allocated_map_title(::std::string* map_title) {
  if (map_title != NULL) {
    
  } else {
    
  }
  map_title_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), map_title);
  // @@protoc_insertion_point(field_set_allocated:NFMsg.ReqMapKingWar.map_title)
}

// -------------------------------------------------------------------

// AckMapKingWar

// bytes map_title = 1;
inline void AckMapKingWar::clear_map_title() {
  map_title_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AckMapKingWar::map_title() const {
  // @@protoc_insertion_point(field_get:NFMsg.AckMapKingWar.map_title)
  return map_title_.GetNoArena();
}
inline void AckMapKingWar::set_map_title(const ::std::string& value) {
  
  map_title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NFMsg.AckMapKingWar.map_title)
}
#if LANG_CXX11
inline void AckMapKingWar::set_map_title(::std::string&& value) {
  
  map_title_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NFMsg.AckMapKingWar.map_title)
}
#endif
inline void AckMapKingWar::set_map_title(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  map_title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NFMsg.AckMapKingWar.map_title)
}
inline void AckMapKingWar::set_map_title(const void* value, size_t size) {
  
  map_title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NFMsg.AckMapKingWar.map_title)
}
inline ::std::string* AckMapKingWar::mutable_map_title() {
  
  // @@protoc_insertion_point(field_mutable:NFMsg.AckMapKingWar.map_title)
  return map_title_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AckMapKingWar::release_map_title() {
  // @@protoc_insertion_point(field_release:NFMsg.AckMapKingWar.map_title)
  
  return map_title_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AckMapKingWar::set_allocated_map_title(::std::string* map_title) {
  if (map_title != NULL) {
    
  } else {
    
  }
  map_title_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), map_title);
  // @@protoc_insertion_point(field_set_allocated:NFMsg.AckMapKingWar.map_title)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace NFMsg

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::NFMsg::ReqAckOprTeamMember_EGTeamMemberOprType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NFMsg::ReqAckOprTeamMember_EGTeamMemberOprType>() {
  return ::NFMsg::ReqAckOprTeamMember_EGTeamMemberOprType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_NFMsgExtra_2eproto
